{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MetaHQ Documentation","text":"<p>Welcome to the MetaHQ documentation!</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udd0d Annotation Retrieval: Query standardized and harmonized biomedical annotations</li> <li>\ud83d\udee0 Core Library: Robust foundation for data curation and ontology management</li> <li>\ud83d\udda5\ufe0f CLI Interface: User-friendly command-line tools</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Quick Start Tutorial</li> <li>CLI User Guide</li> <li>Contributing</li> </ul>"},{"location":"#packages","title":"Packages","text":"<p>MetaHQ consists of two main packages:</p>"},{"location":"#metahq-core","title":"MetaHQ Core","text":"<p>The foundational library for the CLI providing data structures and utilities for annotation querying and manipulation.</p> <p>Learn more about Core \u2192</p>"},{"location":"#metahq-cli","title":"MetaHQ CLI","text":"<p>A command-line interface built on top of MetaHQ Core, providing easy-to-use commands for retrieving biomedical sample and study annotations.</p> <p>Learn more about CLI \u2192</p>"},{"location":"#project-status","title":"Project Status","text":"Package Version Tests core cli"},{"location":"#getting-help","title":"Getting Help","text":"<p>Open an issue on GitHub if you encounter any issues or have questions:</p>"},{"location":"INSTALL/","title":"MetaHQ installation","text":""},{"location":"INSTALL/#normal-install","title":"Normal install","text":"<p>Run the following command:</p> <pre><code>pip install metahq\n</code></pre>"},{"location":"INSTALL/#development-install","title":"Development install","text":""},{"location":"INSTALL/#uv-tools","title":"uv tools","text":"<p>If installing an editable version of <code>metahq</code> locally, use <code>uv tools</code> (docs here).</p> <p>Run the following to install <code>uv tools</code>:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre>"},{"location":"INSTALL/#metahq-install","title":"metahq install","text":"<p>To install <code>metahq</code>, run the following within the root of the <code>metahq</code> repository:</p> <pre><code>uv pip install -e . \".[dev]\"\n</code></pre>"},{"location":"RETRIEVE/","title":"metahq retrieve","text":"<p>With MetaHQ retrieval functions, users can query and manipulate tissue, disease, sex, and age annotations for &gt;250k publicly available microarray and RNA-Seq samples and their corresponding series.</p> <p>Most retrieve commands share the same set of arguments: <code>terms</code>, <code>level</code>, <code>filters</code>, <code>metadata</code>, <code>fmt</code>, and <code>output</code>.</p>"},{"location":"RETRIEVE/#terms","title":"Terms","text":"<p>The <code>terms</code> argument specifies the entities to retrieve annotations for. Queries can be passed as a comma-delimited string of term IDs (e.g., <code>\"UBERON:0000948,UBERON:0000955\"</code>, <code>\"M,F\"</code>) or a text file where each line contains a single term ID. Users may also pass <code>--terms \"all\"</code> to retrieve annotations for all tissues.</p>"},{"location":"RETRIEVE/#level","title":"Level","text":"<p>MetaHQ allows for sample- and series-level annotations specified by passing <code>\"sample\"</code> or <code>\"series\"</code> to the <code>--level</code> argument. Default is <code>sample</code>.</p>"},{"location":"RETRIEVE/#mode","title":"Mode","text":"<p>Tissue and disease retrieval include an additional <code>mode</code> argument allowing users to retrieve direct annotations to the queried terms, propagated annotations, or labels.</p> <ul> <li>direct: The direct annotations submitted by annotation set curators.</li> <li>propagate: For a partiular query, any samples and series directly annotated to that term will be returned as well as any samples/series annotated to any descendants of the query term.   For example, if the query is <code>heart</code> (UBERON:0000948), then any samples or series annotated to <code>myocardium</code> (UBERON:0002349) and any other descendants of heart will also be included.</li> <li>label: For a given query, any entries directly annotated to the term or one of it's descendants are assigned a +1, any entries directly annotated to an ancestor of that term are assigned   a 0 label (or unknown), and all other entries are assigned a -1 label. Additionally, disease labels include samples annotated as healthy controls. These samples are assigned a label of 2 to diseases   that any of the other samples from the same series as the control sample are annotated to.</li> </ul> <p>Default is <code>direct</code>.</p>"},{"location":"RETRIEVE/#filters","title":"Filters","text":"<p>Users can filter for various attributes of the annotations. Filters should be passed as a single string with entries separated by commas (e.g. <code>\"species=human,ecode=expert,technology=rnaseq\"</code>).</p>"},{"location":"RETRIEVE/#species","title":"species","text":"<p>A vast majority of annotations are derived from human samples and series, but all of the following species are queriable:</p> <ul> <li>human (homo sapiens)</li> <li>mouse (mus musculus)</li> <li>rat (rattus norvegicus)</li> <li>fish (danio rerio)</li> <li>fly (drosolphila melanogaster)</li> <li>worm (caenorhabditis elegans)</li> </ul>"},{"location":"RETRIEVE/#ecode","title":"ecode","text":"<ul> <li>expert: Annotations derived from expert curators.</li> <li>semi: Annotations that were predicted using some automated system where a subset of those predictions were checked by an expert.</li> <li>crowd: Annotations derived from non-experts and crowd-sourced projects.</li> </ul>"},{"location":"RETRIEVE/#technology","title":"technology","text":"<p>Currently MetaHQ only contains annotations for microarray and rnaseq</p> <ul> <li>microarray: Annotations derived from expert curators.</li> <li>rnaseq: Annotations that were predicted using some automated system where a subset of those predictions were checked by an expert.</li> </ul>"},{"location":"RETRIEVE/#metadata","title":"Metadata","text":"<p>Users can include verious metadata associated with returned samples and series.</p> <p>At the sample level, users can include the following:</p> <ul> <li>sample</li> <li>series</li> <li>platform</li> <li>description</li> <li>srx</li> <li>srs</li> <li>srp</li> </ul> <p>At the series level, users can include the following:</p> <ul> <li>series</li> <li>platform</li> <li>description</li> <li>srp</li> </ul> <p>The defualt argument is the annotation level.</p>"},{"location":"RETRIEVE/#formats","title":"Formats","text":"<p>The following file formats are supported:</p> <ul> <li>csv</li> <li>tsv</li> <li>parquet</li> <li>json</li> </ul> <p>For large queries (e.g., <code>--terms \"all\"</code>), we recommend using the <code>parquet</code> format. Default is <code>parquet</code>.</p>"},{"location":"RETRIEVE/#tissues","title":"tissues","text":"<p>Tissue queries require ontology term ID inputs. To find the appropriate term ID for your context of interest, see metahq search or the EMBL-EBI ontology lookup service here. Only ontology term IDs can be input to the <code>term</code> argument.</p>"},{"location":"RETRIEVE/#example","title":"Example:","text":"<p><code>metahq retrieve tissues --terms \"UBERON:0000948,UBERON:0000955\" --level sample --mode label --filters \"species=human,ecode=expert,technology=rnaseq\" --metadata \"sample,series,platform\" --fmt tsv --output annotations.tsv</code></p>"},{"location":"RETRIEVE/#diseases","title":"diseases","text":"<p>Diseases are queriable in a similar manner as tissues. Only ontology term IDs can be input to the <code>term</code> argument.</p>"},{"location":"RETRIEVE/#example_1","title":"Example:","text":"<p><code>metahq retrieve diseases --terms \"MONDO:0004994,MONDO:0018177\" --level sample --mode label --filters \"species=human,ecode=expert,technology=rnaseq\" --metadata \"sample,series,platform\" --fmt tsv --output annotations.tsv</code></p>"},{"location":"RETRIEVE/#sex","title":"sex","text":"<p>Direct annotations are queriable for biological sex. There is no <code>mode</code> argument since only direct annotations can be returned. All other arguments are the same.</p>"},{"location":"RETRIEVE/#example_2","title":"Example:","text":"<p><code>metahq retrieve sex --terms \"M,F\" --level sample --filters \"species=human,ecode=expert,technology=rnaseq\" --metadata \"sample,series,platform\" --fmt tsv --output annotations.tsv</code></p>"},{"location":"RETRIEVE/#age","title":"age","text":"<p>Users can query age group labels. Age groups are defined by hormone levels throughout the human life cycle described by Ober, Liosel, and Gilad (2008). Supported age groups are <code>fetus</code>, <code>infant</code>, <code>child</code>, <code>adolescent</code>, <code>adult</code>, <code>older_adult</code>, and <code>elderly_adult</code>.</p> <p>Simliar to sex retrieval, there is no <code>mode</code> argument since only direct annotations can be returned.</p>"},{"location":"RETRIEVE/#example_3","title":"Example:","text":"<p><code>metahq retrieve age --terms \"infant,older_adult\" --level sample --filters \"species=human,ecode=expert,technology=rnaseq\" --metadata \"sample,series,platform\" --fmt tsv --output annotations.tsv</code></p>"},{"location":"RETRIEVE/#references","title":"References","text":"<p>Ober, C., Loisel, D. A., &amp; Gilad, Y. (2008). Sex-specific genetic architecture of human disease. Nature Reviews Genetics, 9(12), 911-922.</p>"},{"location":"SCRIPTS/","title":"Meta-hq Scripts","text":"<p>This directory contains scripts for managing meta-hq's data dependencies and other tasks.</p>"},{"location":"SCRIPTS/#available-scripts","title":"Available Scripts","text":"<ul> <li><code>build_onto_duckdb.py</code>: This script builds the ontology DuckDB database from provided ontology name/synonym dictionaries. It creates the necessary tables and full-text search indices to support the <code>metahq search</code> command.</li> </ul>"},{"location":"SCRIPTS/#usage","title":"Usage","text":"<p>Ideally you should be in the metahq environment to run these scripts. See the repo root README for instructions on setting up the environment.</p> <p>To run the <code>build_onto_duckdb.py</code> script, from the repo root run the following command:</p> <pre><code>python scripts/build_onto_duckdb.py\n</code></pre> <p>This will result in a DuckDB database file named <code>ontology/ontology_search.duckdb</code> under the <code>data_dir</code> folder specified in your meta-hq <code>config.yaml</code>.</p>"},{"location":"SEARCH/","title":"metahq search","text":"<p>This function identifies the ontology term IDs most similar to a user's free-text query. It leverages the BM25 algorithm with the rankbm25 package to perform a lexical search of a query term to the term names and their synonyms in an ontology.</p>"},{"location":"SEARCH/#query","title":"query","text":"<p>Any free text input (e.g., \"heart attack\", \"hepatocyte\").</p>"},{"location":"SEARCH/#type","title":"type","text":"<p>Supported types are:</p> <ul> <li>tissue</li> <li>disease</li> <li>celltype</li> </ul>"},{"location":"SEARCH/#ontology","title":"ontology","text":"<p>Supported ontologies are:</p> <ul> <li>UBERON for tissues and cell types</li> <li>CL for cell types</li> <li>MONDO for diseases</li> </ul>"},{"location":"SEARCH/#max-results-k","title":"max-results (k)","text":"<p>Users can specify the number of top term ID matches to the query that are returned.</p>"},{"location":"SEARCH/#scores","title":"scores","text":"<p>If passed, will return the score from the BM25 algorithm.</p>"},{"location":"SEARCH/#extended","title":"extended","text":"<p>If passed, will return the ontology and type in the results.</p>"},{"location":"SEARCH/#scopes","title":"scopes","text":"<p>If passed, will return the scopes of term synonyms in the results.</p>"},{"location":"about/license/","title":"License","text":"<p>BSD 3-Clause License</p> <p>Copyright (c) 2025, Krishnan Lab</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li> <p>Redistributions of source code must retain the above copyright notice, this    list of conditions and the following disclaimer.</p> </li> <li> <p>Redistributions in binary form must reproduce the above copyright notice,    this list of conditions and the following disclaimer in the documentation    and/or other materials provided with the distribution.</p> </li> <li> <p>Neither the name of the copyright holder nor the names of its    contributors may be used to endorse or promote products derived from    this software without specific prior written permission.</p> </li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"about/mission/","title":"The MetaHQ Mission","text":"<p>We aim for MetaHQ to become a hub for high-quality annotations for biomedical data of all types.</p> <p>The construction of the MetaHQ database would not be possible without efforts from the greater biomedical research community. All of our annotations come from fellow researchers interested in using publicly available biomedical data that understand the difficulty in finding samples and studies of interest.</p> <p>We encourage researchers to submit their high-quality, manually curated annotations to be included in the MetaHQ database! See our Contributing docs for information on how to contribute.</p>"},{"location":"developer/contributing/","title":"Contributing","text":"<p>Thank you for contributing to MetaHQ!</p>"},{"location":"developer/contributing/#ways-to-contribute","title":"Ways to contribute","text":"<p>There are two main ways to contribute to MetaHQ.</p> <ol> <li>Add new standardized sample and/or dataset annotations to the database.</li> <li>Add to the codebase.</li> </ol> <p>Substantial contributions through these means will result in authorship on future MetaHQ releases and publications.</p>"},{"location":"developer/contributing/#database-contributions","title":"Database contributions","text":"<p>The primary goal of the MetaHQ database is to harmonize large collections of curated annotations. To maintain the quality and scale of the database, we focus on incorporating substantial annotation collections rather than individual or small-scale additions.</p> <p>Contribution guidelines:</p> <ul> <li>Datasets: Collections of &gt;100 datasets</li> <li>Samples: Collections of &gt;600 samples</li> <li>All entries in the submission must be annotated to terms in a controlled vocabulary</li> <li>All entries must be from publicly available repositories</li> </ul> <p>While these are not strict cutoffs, they reflect the scale we aim to maintain. If you have a collection that approaches but doesn't quite meet these thresholds and you believe it would be valuable to the community, please reach out to discuss \u2014 we evaluate contributions on a case-by-case basis.</p> <p>See our example annotation submission for guidance on formatting and structure.</p>"},{"location":"developer/contributing/#submitting-database-contributions","title":"Submitting database contributions","text":"<p>Please submit a pull request to github.com/krishnanlab/meta-hq. Use the following template to submit the PR:</p> <pre><code>## Dataset Submission\n\n### Title\n[Dataset name]\n\n### Contributors\n[List all contributors who should receive authorship credit]\n\n### Description\n[Brief description of what this dataset contains and its scientific/research context]\n\n### Dataset Details\n- **Number of samples or datasets:**\n- **Data type(s):** [RNA-Seq, microarray, histopatholgy images, Hi-C, long-read sequencing, etc.]\n- **Evidence code:** [expert-curated, semi-curated, crowd-sourced]\n- **Source:** [GEO, SRA, TCGA, PRIDE, MetaboLites, etc.]\n- **Relevant publication(s):** [Not required. Include DOI if applicable]\n\n### Standardization\n- [ ] All entries are annotated to terms in a controlled vocabulary\n- [ ] Annotations are complete and validated according to the evidence code\n\n### Additional Notes\n[Any additional context, caveats, or information reviewers should know]\n\n---\n\n**Checklist:**\n- [ ] I have read the contributing guidelines\n- [ ] All contributors listed have agreed to their inclusion\n</code></pre>"},{"location":"developer/contributing/#codebase-contributions","title":"Codebase contributions","text":"<p>We welcome code contributions that enhance MetaHQ's functionality, fix bugs, or improve performance. Examples of substantial codebase contributions include:</p> <ul> <li>New features or modules</li> <li>Bug fixes</li> <li>Performance optimizations</li> <li>Test coverage improvements</li> <li>Significant refactoring</li> </ul> <p>Note on documentation changes: While we appreciate improvements to documentation, changes limited to README files, typo fixes, or minor formatting adjustments alone do not typically qualify for authorship. However, documentation contributions paired with code changes, or comprehensive documentation efforts (e.g., adding detailed API documentation, tutorials, or usage guides) are valued and considered substantial contributions.</p>"},{"location":"developer/contributing/#submitting-code-contributions","title":"Submitting code contributions","text":"<p>To submit codebase contributions, please use the following PR template:</p> <pre><code># What\n[High-level explanation of the PR]\n\n# Why\n[Explain why these changes are necessary]\n\n# How\n[High-level explanation of the approach taken]\n\n## Changes made\n[Detailed description of the changes made]\n\n# PR Checklist\n- [ ] Explained the purpose of this PR\n- [ ] Self-reviewed this PR\n- [ ] Added/updated tests\n- [ ] Updated documentation (if applicable)\n</code></pre>"},{"location":"developer/setup/","title":"Dev Setup","text":"<p>Clone the <code>meta-hq</code> repository:</p> httpsssh <pre><code>git clone https://github.com/krishnanlab/meta-hq.git\n</code></pre> <pre><code>git clone git@github.com:krishnanlab/meta-hq.git\n</code></pre>"},{"location":"developer/setup/#install-packages","title":"Install packages","text":"<p>We highly recommend using <code>uv</code> for install. The <code>meta-hq</code> repository is a structured as a monorepo <code>uv workspace</code> with the <code>metahq-cli</code> and <code>metahq-core</code> packages in <code>packages/cli</code> and <code>packages/core</code>, respectively.</p> <p>Install with:</p> Make (Recommended)uvManual <pre><code>make dev\n</code></pre> <pre><code>uv pip install -e . \".[dev]\"\n</code></pre> <pre><code>pip install -e packages/core[dev]\npip install -e packages/cli[dev]\n</code></pre>"},{"location":"developer/setup/#configure-the-package","title":"Configure the package","text":"<p>Download the database and configure both packages.</p> <pre><code>metahq setup\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>We recommend using the <code>uv</code> package manager to install <code>metahq</code> packages. It is a modern, simple, and fast Rust-based package manager. See the following link to install <code>uv</code>: https://docs.astral.sh/uv/getting-started/installation</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>python&gt;=3.12</code></li> <li><code>pip</code> or <code>uv</code></li> </ul>"},{"location":"getting-started/installation/#cli-recommended","title":"CLI (Recommended)","text":"<p>Run the following to install the CLI. This will also install <code>metahq-core</code> by default.</p> pipuv <pre><code>pip install metahq-cli\n</code></pre> <pre><code>uv add metahq-cli\n</code></pre>"},{"location":"getting-started/installation/#core-only","title":"Core only","text":"<p>Run the following to install <code>metahq-core</code>.</p> pipuv <pre><code>pip install metahq-core\n</code></pre> <pre><code>uv add metahq-core\n</code></pre>"},{"location":"getting-started/installation/#install-from-source","title":"Install from Source","text":""},{"location":"getting-started/installation/#1-clone-the-repository","title":"1) Clone the repository","text":"<pre><code>git clone https://github.com/krishnanlab/meta-hq.git\ncd meta-hq\n</code></pre>"},{"location":"getting-started/installation/#2-install-packages","title":"2) Install packages","text":"<p>Using <code>make</code> requires <code>uv</code> and will automatically create a <code>uv venv</code>. run <code>source .venv/bin/activate</code> to activate it.</p> Make (Recommended)pippip (from tar) <pre><code>make install\n</code></pre> <pre><code>pip install packages/core packages/cli\n</code></pre> <pre><code>pip install dist/metahq_core-0.1.2.tar.gz dist/metahq_cli-0.1.1.tar.gz\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For contributing or development:</p> Make (Recommended)uvManual <pre><code>make dev\n</code></pre> <pre><code>uv pip install -e . \".[dev]\"\n</code></pre> <pre><code>pip install -e packages/core[dev]\npip install -e packages/cli[dev]\n</code></pre>"},{"location":"getting-started/quickstart/","title":"CLI Quickstart","text":"<p>Every installation of the MetaHQ CLI requires the <code>setup</code> command to be run. This will download the MetaHQ database from Zenodo and configure the package.</p>"},{"location":"getting-started/quickstart/#setup","title":"Setup","text":"<p>Download the latest MetaHQ database and configure the CLI:</p> <pre><code>$ metahq setup\n</code></pre>"},{"location":"getting-started/quickstart/#retrieve","title":"Retrieve","text":"<p>Query the database for curated, biological context annotations. Below is an example of a query for expert-curated tissue annotations from human RNA-Seq samples:</p> <pre><code>$ metahq retrieve tissues --terms \"UBERON:0000948,UBERON:0000955\" \\\n    --level sample --filters \"species=human,tech=rnaseq,ecode=expert\" \\\n    --metadata \"sample,series,description\" --fmt tsv --output annotations.tsv\n</code></pre> <p>See the retrieve documentation for more details.</p>"},{"location":"getting-started/quickstart/#search","title":"Search","text":"<p>Tissue and disease queries require standardized ontology term ID inputs. The following command will identify the top five most similar MONDO disease ontology term IDs to \"heart attack\".</p> <pre><code>$ metahq search --query \"heart attack\" --type disease --ontology MONDO -k 5\n</code></pre> <p>The EBI Ontology Lookup Service is also an excellent way to find term IDs. See the links below:</p> <p>UBERON/CL (tissues/celltypes): https://www.ebi.ac.uk/ols4/ontologies/uberon\\ MONDO (diseases): https://www.ebi.ac.uk/ols4/ontologies/mondo</p>"},{"location":"packages/","title":"MetaHQ Packages","text":"<p>MetaHQ consists of two main packages:</p>"},{"location":"packages/#metahq-core","title":"MetaHQ Core","text":"<p>The foundational library for the CLI providing data structures and utilities for annotation querying and manipulation.</p> <p>Core documentation \u2192</p>"},{"location":"packages/#metahq-cli","title":"MetaHQ CLI","text":"<p>A command-line interface built on top of MetaHQ Core, providing easy-to-use commands for retrieving biomedical sample and study annotations.</p> <p>CLI documentation\u2192</p>"},{"location":"packages/cli/api/builder/","title":"Builder","text":"<p>Class to build query, curation, and output configurations for <code>metahq retrieve</code>. Exists to support modularity and reduce redundnacy in the retrieval commands.</p>"},{"location":"packages/cli/api/builder/#metahq_cli.retrieval_builder.Builder.get_filters","title":"<code>get_filters(filters)</code>","text":"<p>Parses and checks requested filters.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>str</code> <p>A comma-delimited string of supported MetaHQ filters.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>A dictionary of filter key, values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_cli.retrieval_builder import Builder\n&gt;&gt;&gt; builder = Builder()\n&gt;&gt;&gt; filters = 'species=human,ecode=expert,tech=rnaseq'\n&gt;&gt;&gt; builder.get_filters()\n{'species': 'human', 'ecode': 'expert', 'tech': 'rnaseq'}\n</code></pre>"},{"location":"packages/cli/api/builder/#metahq_cli.retrieval_builder.Builder.parse_onto_terms","title":"<code>parse_onto_terms(terms, reference)</code>","text":"<p>Collects passed query terms and checks if they are appropriate.</p> <p>Attributes:</p> Name Type Description <code>terms</code> <code>list[str]</code> <p>A list of ontology term IDs. Can be ontology IDs for tissues or diseases. (e.g., <code>['UBERON:0000948', 'UBERON:0000955']</code>).</p> <code>reference</code> <code>str</code> <p>An indication of what kind of terms these are (e.g., 'UBERON' or 'MONDO').</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Any terms that are supported within MetaHQ.</p>"},{"location":"packages/cli/api/builder/#metahq_cli.retrieval_builder.Builder.query_config","title":"<code>query_config(db, attribute, level, filters)</code>","text":"<p>Construct a query configuration.</p> <p>Query parameters are checked in the metahq_core.query module.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>str</code> <p>The name of a supported database within MetaHQ.</p> required <code>attribute</code> <code>str</code> <p>A supported attribute within MetaHQ.</p> required <code>level</code> <code>str</code> <p>A level of annotations (e.g., <code>'sample'</code> or <code>'series'</code>).</p> required <code>filters</code> <code>dict[str, str]</code> <p>Filters parsed by <code>Builder.get_filters</code>.</p> required <p>Returns:</p> Type Description <code>QueryConfig</code> <p>A populated <code>QueryConfig</code>.</p>"},{"location":"packages/cli/api/builder/#metahq_cli.retrieval_builder.Builder.curation_config","title":"<code>curation_config(terms, mode, ontology)</code>","text":"<p>Construct a curation configuration.</p> <p>Attributes:</p> Name Type Description <code>terms</code> <code>str</code> <p>A list of terms to curate annotations for.</p> <code>mode</code> <code>str</code> <p>A supported curation mode (e.g., <code>'annotate'</code>, <code>'label'</code>).</p> <code>ontology</code> <code>str</code> <p>An ontology to use for propagating annotations and assigning labels.</p> <p>Returns:</p> Type Description <code>CurationConfig</code> <p>A populated <code>CurationConfig</code>.</p>"},{"location":"packages/cli/api/builder/#metahq_cli.retrieval_builder.Builder.output_config","title":"<code>output_config(outfile, fmt, metadata, level)</code>","text":"<p>Construct an output configuration.</p> <p>Attributes:</p> Name Type Description <code>outfile</code> <code>str | Path</code> <p>Path to file to store annotations.</p> <code>fmt</code> <code>Literal[json, parquet, csv, tsv]</code> <p>Format of the output file.</p> <code>metadata</code> <code>str</code> <p>Comma-delimited string indicating which metadata fields to include.</p> <code>level</code> <code>str</code> <p>Annotation level to check if any of the requested metadata fields are     available for the requested level.</p> <p>Returns:</p> Type Description <code>OutputConfig</code> <p>A populated <code>OutputConfig</code>.</p>"},{"location":"packages/cli/api/builder/#metahq_cli.retrieval_builder.Builder.make_age_curation","title":"<code>make_age_curation(terms, mode)</code>","text":"<p>Makes an age-specific CurationConfig.</p>"},{"location":"packages/cli/api/builder/#metahq_cli.retrieval_builder.Builder.make_sex_curation","title":"<code>make_sex_curation(terms, mode)</code>","text":"<p>Sex-specific curation.</p>"},{"location":"packages/cli/api/builder/#metahq_cli.retrieval_builder.Builder.report_bad_filters","title":"<code>report_bad_filters(filters)</code>","text":"<p>Check filters and return improper filter parameters.</p>"},{"location":"packages/cli/api/retriever/","title":"Retriever","text":"<p>Queries, curates, and saves MetaHQ annotations for <code>metahq retrieve</code>. Exists to reduce redundancy in MetaHQ retrieve commands.</p> <p>Attributes:</p> Name Type Description <code>query_config</code> <code>QueryConfig</code> <p>QueryConfig Parameters for querying.</p> <code>curation_config</code> <code>CurationConfig</code> <p>CurationConfig Parameters for curating annotations.</p> <code>output_config</code> <code>OutputConfig</code> <p>OutputConfig Parameters for saving curations.</p>"},{"location":"packages/cli/api/retriever/#metahq_cli.retriever.Retriever.curate","title":"<code>curate(annotations)</code>","text":"<p>Mutate curations by specified mode.</p> <p>Parameters:</p> Name Type Description Default <code>annotations</code> <code>Annotations</code> <p>Annotations A populated Annotations object.</p> required <p>Returns:</p> Type Description <p>A populated Annotations or Labels object given the specified curation mode.</p>"},{"location":"packages/cli/api/retriever/#metahq_cli.retriever.Retriever.query","title":"<code>query()</code>","text":"<p>Performs a MetaHQ query</p>"},{"location":"packages/cli/api/retriever/#metahq_cli.retriever.Retriever.retrieve","title":"<code>retrieve()</code>","text":"<p>Performs the retrieval pipeline: query -&gt; curate -&gt; save.</p>"},{"location":"packages/cli/api/retriever/#metahq_cli.retriever.Retriever.save_curation","title":"<code>save_curation(curation)</code>","text":"<p>Saves the curation.</p> <p>Parameters:</p> Name Type Description Default <code>curation</code> <code>Annotations | Labels</code> <p>A populated Annotations or Labels object to save.</p> required"},{"location":"packages/cli/api/configs/curation/","title":"CurationConfig","text":"<p>Storage for query parameters.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>str</code> <p>The name of a supported database within MetaHQ.</p> <code>attribute</code> <code>str</code> <p>A supported attribute within MetaHQ.</p> <code>level</code> <code>str</code> <p>A level of annotations (e.g., 'sample' or 'series').</p> <code>ecode</code> <code>str</code> <p>Evidence code (e.g., 'expert', 'crowd', 'any')</p> <code>species</code> <code>str</code> <p>A supported species within MetaHQ.</p> <code>tech</code> <code>str</code> <p>A supported technology within MetaHQ.</p>"},{"location":"packages/cli/api/configs/output/","title":"OutputConfig","text":"<p>Storage for query parameters.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>str</code> <p>The name of a supported database within MetaHQ.</p> <code>attribute</code> <code>str</code> <p>A supported attribute within MetaHQ.</p> <code>level</code> <code>str</code> <p>A level of annotations (e.g., 'sample' or 'series').</p> <code>ecode</code> <code>str</code> <p>Evidence code (e.g., 'expert', 'crowd', 'any')</p> <code>species</code> <code>str</code> <p>A supported species within MetaHQ.</p> <code>tech</code> <code>str</code> <p>A supported technology within MetaHQ.</p>"},{"location":"packages/cli/api/configs/query/","title":"QueryConfig","text":"<p>Storage for output parameters.</p> <p>Attributes:</p> Name Type Description <code>outfile</code> <code>str | Path</code> <p>Path to file to store annotations.</p> <code>fmt</code> <code>Literal['json', 'parquet', 'csv', 'tsv']</code> <p>Format of the output file.</p> <code>metadata</code> <code>str</code> <p>Comma-delimited string indicating which metadata fields to include.</p>"},{"location":"packages/cli/api/setup/config/","title":"Config","text":"<p>Class to store and assess and create the meta-hq configuration file.</p> <p>Attributes:</p> Name Type Description <code>version</code> <code>str</code> <p>A version name of the MetaHQ database (e.g., <code>'v0.1.0'</code>).</p> <code>zenodo_doi</code> <code>str</code> <p>A DOI of the MetaHQ database in Zenodo.</p> <code>data_dir</code> <code>str</code> <p>Path to where the MetaHQ data are stored.</p> <code>logs</code> <code>str</code> <p>Path to where the MetaHQ logs are stored.</p> <code>ok_keys</code> <code>list[str]</code> <p>Acceptable keys in the config.</p>"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.path","title":"<code>path</code>  <code>property</code>","text":"<p>Returns <code>/path/to/config.yaml</code></p>"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.check","title":"<code>check()</code>","text":"<p>Checks if the meta-hq config exists. Initializes if not.</p>"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.is_acceptable_config","title":"<code>is_acceptable_config()</code>","text":"<p>Checks if config has correct structure.</p>"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.load_config","title":"<code>load_config()</code>","text":"<p>Loads the meta-hq config file.</p>"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.load_config_str","title":"<code>load_config_str()</code>","text":"<p>Loads the meta-hq config file.</p>"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.make_config","title":"<code>make_config()</code>","text":"<p>Creates the config dictionary</p>"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.save_config","title":"<code>save_config(config)</code>","text":"<p>Saves a config file.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict[str, str]</code> <p>A config with acceptable keys.</p> required"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.setup","title":"<code>setup()</code>","text":"<p>Main setup function.</p>"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.set_default","title":"<code>set_default()</code>","text":"<p>Makes a default meta-hq config.</p>"},{"location":"packages/cli/api/setup/config/#metahq_cli.setup.config.Config.initialize_config","title":"<code>initialize_config()</code>","text":"<p>Initialize the meta-hq config file.</p>"},{"location":"packages/cli/api/setup/download/","title":"Downloader","text":"<p>Downloader for the MetaHQ database stored on Zenodo.</p> <p>Attributes:</p> Name Type Description <code>doi</code> <code>str</code> <p>Zenodo DOI for the MetaHQ databse.</p> <code>outdir</code> <code>str</code> <p>Path to the output directory in the user's system.</p> <code>logger</code> <code>Logger</code> <p>Logger for process transparency.</p> <code>verbose</code> <code>bool</code> <p>Indicates if logs should be passed to stdout.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_cli.downloader import Downloader\n&gt;&gt;&gt; downloader = Downloader('17663087')\n&gt;&gt;&gt; downloader.get()\n&gt;&gt;&gt; downloader.extract()\n</code></pre>"},{"location":"packages/cli/api/setup/download/#metahq_cli.setup.downloader.Downloader.database_version","title":"<code>database_version</code>  <code>property</code>","text":"<p>Return the MetaHQ database version.</p>"},{"location":"packages/cli/api/setup/download/#metahq_cli.setup.downloader.Downloader.check_outdir_exists","title":"<code>check_outdir_exists()</code>","text":"<p>Check if the data directory exists.</p>"},{"location":"packages/cli/api/setup/download/#metahq_cli.setup.downloader.Downloader.extract","title":"<code>extract()</code>","text":"<p>Extract the tar archive.</p>"},{"location":"packages/cli/api/setup/download/#metahq_cli.setup.downloader.Downloader.get","title":"<code>get()</code>","text":"<p>Downloads the database .tar.gz file from Zenodo.</p>"},{"location":"packages/cli/api/setup/download/#metahq_cli.setup.downloader.Downloader.get_stats","title":"<code>get_stats()</code>","text":"<p>Check if file exists and retrieve file stats.</p>"},{"location":"packages/cli/commands/retrieve/","title":"metahq retrieve","text":"<p>Retrieval commands for tissue, disease, sex, and age annotations.</p> <p>Usage:</p> <pre><code>metahq retrieve [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"packages/cli/commands/retrieve/#age","title":"age","text":"<p>Retrieval command for age group annotations.</p> <p>Usage:</p> <pre><code>metahq retrieve age [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --terms [fetus|infant|child|adolescent|adult|older_adult|eldery_adult|all]\n                                  Age groups to choose. Can combine like\n                                  'fetus,adult'.\n  --level [sample|series]         GEO annotation level.\n  --filters TEXT                  Filters for species, ecode, and technology.\n                                  Run `metahq supported` for options.\n  --output PATH                   Path to outfile.\n  --fmt [parquet|tsv|csv|json]\n  --metadata TEXT\n  --log-level [notset|debug|info|warning|error|critical]\n                                  Logging level.\n  --quiet                         No log or console output if applied.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"packages/cli/commands/retrieve/#diseases","title":"diseases","text":"<p>Retrieval command for disease ontology terms.</p> <p>Usage:</p> <pre><code>metahq retrieve diseases [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --terms TEXT\n  --level [sample|series]         GEO annotation level.\n  --filters TEXT                  Filters for species, ecode, and technology.\n                                  Run `metahq supported` for options.\n  --output PATH                   Path to outfile.\n  --fmt [parquet|tsv|csv|json]\n  --metadata TEXT\n  --mode [annotate|label]         Retrieve annotations or labels.\n  --log-level [notset|debug|info|warning|error|critical]\n                                  Logging level.\n  --quiet                         No log or console output if applied.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"packages/cli/commands/retrieve/#sex","title":"sex","text":"<p>Retrieval command for sex annotations.</p> <p>Usage:</p> <pre><code>metahq retrieve sex [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --terms TEXT\n  --level [sample|series]         GEO annotation level.\n  --filters TEXT                  Filters for species, ecode, and technology.\n                                  Run `metahq supported` for options.\n  --output PATH                   Path to outfile.\n  --fmt [parquet|tsv|csv|json]\n  --metadata TEXT\n  --log-level [notset|debug|info|warning|error|critical]\n                                  Logging level.\n  --quiet                         No log or console output if applied.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"packages/cli/commands/retrieve/#tissues","title":"tissues","text":"<p>Retrieval command for tissue ontology terms.</p> <p>Usage:</p> <pre><code>metahq retrieve tissues [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --terms TEXT\n  --level [sample|series]         GEO annotation level.\n  --filters TEXT                  Filters for species, ecode, and technology.\n                                  Run `metahq supported` for options.\n  --output PATH                   Path to outfile.\n  --fmt [parquet|tsv|csv|json]\n  --metadata TEXT\n  --mode [annotate|label]         Retrieve annotations or labels.\n  --log-level [notset|debug|info|warning|error|critical]\n                                  Logging level.\n  --quiet                         No log or console output if applied.\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"packages/cli/commands/search/","title":"metahq search","text":"<p>Search for terms in the ontology database.</p> <p>Usage:</p> <pre><code>metahq search [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  --query TEXT                    Search query  [required]\n  -c, --type [disease|tissue|celltype|none]\n                                  Filter by type\n  -o, --ontology [MONDO|UBERON|CL]\n                                  Filter by ontology\n  -k, --max-results INTEGER       Number of results to show\n  -s, --scores                    Include scores in results\n  -e, --extended                  Include ontology and type in results\n  -x, --scopes                    Include scopes in synonym list\n  --log-level [notset|debug|info|warning|error|critical]\n                                  Logging level.\n  --quiet                         No log or console output if applied.\n  -h, --help                      Show this message and exit.\n</code></pre>"},{"location":"packages/cli/commands/setup/","title":"metahq setup","text":"<p>Download the MetaHQ database and configure the CLI.</p> <p>Usage:</p> <pre><code>metahq setup [OPTIONS]\n</code></pre> <p>Options:</p> <pre><code>  -d, --doi TEXT                  Zenodo DOI of the MetaHQ database. Default\n                                  is `latest`.\n  -o, --data-dir PATH             Path to directory to store the database.\n                                  Default is `/home/path/.metahq_data`.\n  -l, --log-dir PATH              Path to directory storing logs. Default is\n                                  `/home/path/MetaHQ`.\n  --log-level [notset|debug|info|warning|error|critical]\n                                  Logging level.\n  --quiet                         No log or console output if applied.\n  -h, --help                      Show this message and exit.\n</code></pre>"},{"location":"packages/core/overview/","title":"MetaHQ Core","text":""},{"location":"packages/core/api/logger/","title":"Logger","text":"<p>Logger setup.</p> <p>Author: Parker Hicks Date: 2025-10-16</p> <p>Last updated: 2025-11-28 by Parker Hicks</p>"},{"location":"packages/core/api/logger/#metahq_core.logger.setup_logger","title":"<code>setup_logger(name, log_dir, level=logging.INFO)</code>","text":"<p>Sets up a logger.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Logger name.</p> required <code>log_dir</code> <code>str | Path</code> <p>Path to logging directory. Default is ~/metahq/logs</p> required <code>level</code> <code>int</code> <p>Logging level.</p> <code>INFO</code> <p>Returns:</p> Type Description <code>Logger</code> <p>Configured logger.</p>"},{"location":"packages/core/api/search/","title":"Search","text":"<p>Given a query string, return the top k hits from the ontology search index.</p> <p>The search index is built from the ontology terms' names and synonyms, where names are weighted more heavily than synonyms. The search uses the BM25+ algorithm to rank the results.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query string.</p> required <code>db</code> <code>Path | None</code> <p>Path to the DuckDB database file, or None to use the default location.</p> <code>None</code> <code>k</code> <code>int</code> <p>The number of top hits to return.</p> <code>20</code> <code>type</code> <code>str | None</code> <p>If given, restrict results to this type (e.g. \"celltype\", \"disease\", or \"tissue\").</p> <code>None</code> <code>ontology</code> <code>str | None</code> <p>If given, restrict results to this ontology (e.g. \"CL\", \"UBERON\", or \"MONDO\").</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, print debug information.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A <code>polars.DataFrame</code> object with columns: term_id, ontology, name, type, synonyms, score.</p> <p>Build the doc_text column for BM25 indexing from the name and synonyms.</p> <p>See the NAME_WEIGHT and SCOPE_WEIGHTS constants for how parts of the record are weighted in the resulting document.</p> <p>Per the OBO 1.4 spec, synonyms can have scopes in {EXACT, BROAD, NARROW, RELATED}. If no scope is given, it is treated as RELATED.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The primary name of the term.</p> required <code>syns</code> <code>list[SynonymEntry]</code> <p>List of {\"text\": str, \"scope\": str|None} synonym entries.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A string suitable for BM25 indexing.</p> <p>               Bases: <code>TypedDict</code></p> <p>Storage of synonyms and their scope.</p> <p>Attributes:</p> Name Type Description <code>text</code> <code>str</code> <p>Any piece of text.</p> <code>scope</code> <code>NotRequired[Literal['EXACT', 'NARROW', 'BROAD', 'RELATED']]</code> <p>The importance of <code>text</code>.</p>"},{"location":"packages/core/api/util/","title":"Util","text":""},{"location":"packages/core/api/util/#io","title":"IO","text":"<p>Input/output functions.</p> <p>Author: Parker Hicks Date: 2025-04</p> <p>Last updated: 2025-11-28 by Parker Hicks</p> <p></p>"},{"location":"packages/core/api/util/#metahq_core.util.io.checkdir","title":"<code>checkdir(path, is_file=False)</code>","text":"<p>Check if directory exists. If not, creates it.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>A path to a directory or file.</p> required <code>is_file</code> <code>bool</code> <p>If <code>True</code> will check the parent of the file path.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>A <code>pathlib.Path</code> object of <code>path</code>.</p>"},{"location":"packages/core/api/util/#metahq_core.util.io.load_bson","title":"<code>load_bson(file, **kwargs)</code>","text":"<p>Load dictionary from compressed bson.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to file.bson to load.</p> required"},{"location":"packages/core/api/util/#metahq_core.util.io.load_json","title":"<code>load_json(file, encoding='utf-8')</code>","text":"<p>Load dictionary from JSON.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to file.json to load.</p> required"},{"location":"packages/core/api/util/#metahq_core.util.io.load_txt","title":"<code>load_txt(file, cols=1, delimiter=',', encoding='utf-8')</code>","text":"<p>Loads a txt file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to file.txt to load.</p> required <code>cols</code> <code>int</code> <p>The number of columns in <code>file</code>.</p> <code>1</code> <code>delimiter</code> <code>str | None</code> <p>Character to separate entries if the <code>cols&gt;1</code>.</p> <code>','</code> <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code> <p>Returns:     An list of strings.</p>"},{"location":"packages/core/api/util/#metahq_core.util.io.load_txt_sections","title":"<code>load_txt_sections(file, delimiter, encoding='utf-8')</code>","text":"<p>Load a .txt file in sections.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to .txt file to load in sections.</p> required <code>delimiter</code> <code>str</code> <p>Pattern to split entries in the .txt file.</p> required <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Sections of the .txt file separated by the specified delimiter.</p>"},{"location":"packages/core/api/util/#metahq_core.util.io.load_yaml","title":"<code>load_yaml(file, encoding='utf-8')</code>","text":"<p>Load a yaml dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to .yaml file to load.</p> required <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code>"},{"location":"packages/core/api/util/#metahq_core.util.io.save_bson","title":"<code>save_bson(data, file, **kwargs)</code>","text":"<p>Save dictionary to compressed bson.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary to compress and save.</p> required <code>file</code> <code>str | Path</code> <p>Path to file.txt to save <code>data</code>.</p> required"},{"location":"packages/core/api/util/#metahq_core.util.io.save_json","title":"<code>save_json(data, file, encoding='utf-8')</code>","text":"<p>Saves a dictionary to file in JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary to save.</p> required <code>file</code> <code>str | Path</code> <p>Path to file.txt to save <code>data</code>.</p> required <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code>"},{"location":"packages/core/api/util/#metahq_core.util.io.save_txt","title":"<code>save_txt(data, file, delimiter=None, encoding='utf-8')</code>","text":"<p>Save an array or list to a <code>.txt</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>StringArray | list[str]</code> <p>An array or list of string entries.</p> required <code>file</code> <code>str | Path</code> <p>Path to file.txt to save <code>data</code>.</p> required <code>delimiter</code> <code>str | None</code> <p>Allows for multidimensional arrays to be saves as     single dimension arrays by concatenating each     element in each row by the passed delimiter.</p> <code>None</code> <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code>"},{"location":"packages/core/api/util/#exceptions","title":"Exceptions","text":""},{"location":"packages/core/api/util/#metahq_core.util.exceptions.NoResultsFound","title":"<code>NoResultsFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when no results are found for a given query.</p>"},{"location":"packages/core/api/util/#helpers","title":"Helpers","text":""},{"location":"packages/core/api/util/#metahq_core.util.helpers.flatten_list","title":"<code>flatten_list(l)</code>","text":"<p>Flattens a list of lists.</p>"},{"location":"packages/core/api/util/#metahq_core.util.helpers.reverse_dict","title":"<code>reverse_dict(d)</code>","text":"<p>Sets values as keys and keys as values.</p>"},{"location":"packages/core/api/util/#metahq_core.util.helpers.subset_keys","title":"<code>subset_keys(dict_, subset)</code>","text":"<p>Subset a dictionary by top level keys.</p>"},{"location":"packages/core/api/util/#metahq_core.util.helpers.merge_list_values","title":"<code>merge_list_values(dict_)</code>","text":"<p>Combine all lists that are values of a dictionary to a single list.</p>"},{"location":"packages/core/api/util/#progress","title":"Progress","text":"<p>Rich progress displays.</p> <p>Author: Parker Hicks Date: 2025-09-25</p> <p>Last updated: 2025-09-26 by Parker Hicks</p> <p></p>"},{"location":"packages/core/api/util/#metahq_core.util.progress.spinner","title":"<code>spinner(desc, p_message, end_message)</code>","text":"<p>Function decorator to apply a rich progress spinner.</p>"},{"location":"packages/core/api/util/#metahq_core.util.progress.progress_bar","title":"<code>progress_bar(padding='')</code>","text":"<p>Creates a custom rich progress bar.</p> <p>Modified from Timothy Gebhard: https://timothygebhard.de/posts/richer-progress-bars-for-rich/</p>"},{"location":"packages/core/api/util/#metahq_core.util.progress.progress_wrapper","title":"<code>progress_wrapper(desc, verbose, total, func, padding='', *args, **kwargs)</code>","text":"<p>Function wrapper to apply a spinner while process ongoing.</p>"},{"location":"packages/core/api/util/#metahq_core.util.progress.get_console","title":"<code>get_console()</code>","text":"<p>Return the Rich Console for console sharing across rich handlers.</p>"},{"location":"packages/core/api/util/#supported","title":"Supported","text":"<p>This script stores file path constants and functions to retrieve those paths.</p> <p>Functions beginning with an underscore are intended to be called through the <code>supported</code> function or are just helpers.</p> <p>Author: Parker Hicks Date: 2025-04-15</p> <p>Last updated: 2025-11-24 by Parker Hicks</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.na_entities","title":"<code>na_entities()</code>","text":"<p>Return annotations not to include</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.disease_ontologies","title":"<code>disease_ontologies()</code>","text":"<p>Return available disease ontologies.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.sexes","title":"<code>sexes()</code>","text":"<p>Return available sexes.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.species_map","title":"<code>species_map()</code>","text":"<p>Return species common and scientific names.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_annotations","title":"<code>get_annotations(level)</code>","text":"<p>Returns the annotations database file for a given level.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_config","title":"<code>get_config()</code>","text":"<p>Loads the MetaHQ config file.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_config_file","title":"<code>get_config_file()</code>","text":"<p>Returns the path to the MetaHQ config file if it exists.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_config_file_no_check","title":"<code>get_config_file_no_check()</code>","text":"<p>Only used to initialize MetaHQ.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_data_dir","title":"<code>get_data_dir()</code>","text":"<p>Extracts the MetaHQ data directory from the config.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_default_data_dir","title":"<code>get_default_data_dir()</code>","text":"<p>Return the default data directory.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_log_dir","title":"<code>get_log_dir()</code>","text":"<p>Return log directory defined in config.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_default_log_dir","title":"<code>get_default_log_dir()</code>","text":"<p>Returns path to default logging directory.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_default_log_file","title":"<code>get_default_log_file()</code>","text":"<p>Returns the path to the default logging file.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.geo_metadata","title":"<code>geo_metadata(level)</code>","text":"<p>Returns the MetaHQ metadata file for the specified level.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_metadata_path","title":"<code>get_metadata_path()</code>","text":"<p>Returns the path to MetaHQ metadata.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_metahq_home","title":"<code>get_metahq_home()</code>","text":"<p>Returns the home directory for MetaHQ.</p> <p>Makes the directory if it doesn't exist.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_ontology_dirs","title":"<code>get_ontology_dirs(onto)</code>","text":"<p>Returns the path to the specified ontology directory.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_ontology_files","title":"<code>get_ontology_files(onto)</code>","text":"<p>Returns the path to the specified ontology obo file.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_ontology_search_db","title":"<code>get_ontology_search_db()</code>","text":"<p>Returns the path to the ontology search database.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_ontology_families","title":"<code>get_ontology_families(onto)</code>","text":"<p>Returns the path to files outlining ontology relationships.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.get_technologies","title":"<code>get_technologies()</code>","text":"<p>Returns the file to technology relationships.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.attributes","title":"<code>attributes(query)</code>","text":"<p>Returns default keys to collect attribute values.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.database_ids","title":"<code>database_ids(query)</code>","text":"<p>Returns supported accession IDs for SRA or GEO.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.ecodes","title":"<code>ecodes(query)</code>","text":"<p>Checks if query is in the supported evidence codes.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.levels","title":"<code>levels(query)</code>","text":"<p>Check if queried level is supported.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.metadata_fields","title":"<code>metadata_fields(level)</code>","text":"<p>Returns supported metadata fields for a specified level.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.ontologies","title":"<code>ontologies(query)</code>","text":"<p>Returns the path to a queried ontology.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.onto_relations","title":"<code>onto_relations(query, relatives)</code>","text":"<p>Returns the path to a queried ontology.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.species","title":"<code>species(query)</code>","text":"<p>Checks if a species is supported by MetaHQ.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.technologies","title":"<code>technologies(query)</code>","text":"<p>Returns supported technologies in MetaHQ.</p>"},{"location":"packages/core/api/util/#metahq_core.util.supported.supported","title":"<code>supported(entity)</code>","text":"<p>Returns supported items for a specified entity.</p>"},{"location":"packages/core/api/curations/annotations/","title":"Annotations","text":"<p>               Bases: <code>BaseCuration</code></p> <p>Class to store and mutate annotations of samples to various attributes like tissues, dieases, sexes, ages, etc.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>DataFrame</code> <p>Polars DataFrame with index and group ID columns and columns for each     attribute entity for each index (e.g. male or female, tissues, diseases, etc).</p> <code>disease</code> <code>bool</code> <p>Indicates if the annotations are disease based. Used to account for control samples     when converting annotations to labels.</p> <code>index_col</code> <code>str</code> <p>Name of the column of data that contains the index IDs.</p> <code>group_cols</code> <code>tuple[str, ...]</code> <p>Names of columns of data that contain an ID for each index indicating if it belongs     to a particular group (e.g. dataset, sex, platform, etc.).</p> <code>collapsed</code> <code>bool</code> <p>Indicates if the annotations have already been collapsed.</p>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.entities","title":"<code>entities</code>  <code>property</code>","text":"<p>Returns term names of the Annotations frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; anno = pl.DataFrame(\n        {\n            \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n            \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n            \"UBERON:0000948\": [1, 0, 0],\n            \"UBERON:0002349\": [1, 1, 0],\n            \"UBERON:0002113\": [0, 0, 0],\n            \"UBERON:0000955\": [0, 0, 1],\n        }\n    )\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.entities\n['UBERON:0000955', 'UBERON:0002349', 'UBERON:0000948', 'UBERON:0002113']\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.groups","title":"<code>groups</code>  <code>property</code>","text":"<p>Returns the groups column of the Annotations curation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; anno = pl.DataFrame(\n        {\n            \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n            \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n            \"UBERON:0000948\": [1, 0, 0],\n            \"UBERON:0002349\": [1, 1, 0],\n            \"UBERON:0002113\": [0, 0, 0],\n            \"UBERON:0000955\": [0, 0, 1],\n        }\n    )\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.groups\n['GSE1', 'GSE1', 'GSE2']\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.ids","title":"<code>ids</code>  <code>property</code>","text":"<p>Return the IDs dataframe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; anno = pl.DataFrame(\n        {\n            \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n            \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n            \"UBERON:0000948\": [1, 0, 0],\n            \"UBERON:0002349\": [1, 1, 0],\n            \"UBERON:0002113\": [0, 0, 0],\n            \"UBERON:0000955\": [0, 0, 1],\n        }\n    )\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.ids\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 sample \u2506 series \u2502\n\u2502 ---    \u2506 ---    \u2502\n\u2502 str    \u2506 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSM1   \u2506 GSE1   \u2502\n\u2502 GSM2   \u2506 GSE1   \u2502\n\u2502 GSM3   \u2506 GSE2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.index","title":"<code>index</code>  <code>property</code>","text":"<p>Return the index column as a list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; anno = pl.DataFrame(\n        {\n            \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n            \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n            \"UBERON:0000948\": [1, 0, 0],\n            \"UBERON:0002349\": [1, 1, 0],\n            \"UBERON:0002113\": [0, 0, 0],\n            \"UBERON:0000955\": [0, 0, 1],\n        }\n    )\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.index\n['GSM1', 'GSM2', 'GSM3']\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.n_indices","title":"<code>n_indices</code>  <code>property</code>","text":"<p>Returns number of indices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; anno = pl.DataFrame(\n        {\n            \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n            \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n            \"UBERON:0000948\": [1, 0, 0],\n            \"UBERON:0002349\": [1, 1, 0],\n            \"UBERON:0002113\": [0, 0, 0],\n            \"UBERON:0000955\": [0, 0, 1],\n        }\n    )\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.n_indices\n3\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.n_entities","title":"<code>n_entities</code>  <code>property</code>","text":"<p>Returns number of entities.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; anno = pl.DataFrame(\n        {\n            \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n            \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n            \"UBERON:0000948\": [1, 0, 0],\n            \"UBERON:0002349\": [1, 1, 0],\n            \"UBERON:0002113\": [0, 0, 0],\n            \"UBERON:0000955\": [0, 0, 1],\n        }\n    )\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.n_entities\n4\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.unique_groups","title":"<code>unique_groups</code>  <code>property</code>","text":"<p>Returns unique groups.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; anno = pl.DataFrame(\n        {\n            \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n            \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n            \"UBERON:0000948\": [1, 0, 0],\n            \"UBERON:0002349\": [1, 1, 0],\n            \"UBERON:0002113\": [0, 0, 0],\n            \"UBERON:0000955\": [0, 0, 1],\n        }\n    )\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.unique_groups\n['GSE2', 'GSE1']\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.add_ids","title":"<code>add_ids(new)</code>","text":"<p>Append new group ID columns to the IDs of an Annotations object. The new IDs must have a matching index.</p> <p>Parameters:</p> Name Type Description Default <code>new</code> <code>DataFrame</code> <p>A DataFrame of additional IDs to join with the current index column of <code>data</code>.     Must have a matching index column as the original <code>data</code>.</p> required <p>Returns:</p> Type Description <code>Annotations</code> <p>A new Annotations object including the new ID columns.</p>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.collapse","title":"<code>collapse(on, inplace=True)</code>","text":"<p>Collapses annotations on the specified grouping column.</p> <p>Parameters:</p> Name Type Description Default <code>on</code> <code>str</code> <p>The column to collapse on. This should be one of the columns in <code>group_cols</code>.</p> required <code>inplace</code> <code>bool</code> <p>If True, updates this object and returns self. Otherwise, returns new object.</p> <code>True</code>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.drop","title":"<code>drop(*args, **kwargs)</code>","text":"<p>Wrapper for polars drop. Drops any of the term columns. ID columns are not dropped through this method.</p>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.filter","title":"<code>filter(condition)</code>","text":"<p>Filter both data and ids simultaneously using a mask.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Expr</code> <p>Polars expression for filtering columns.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.annotations import Annotations\n&gt;&gt;&gt; anno = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, 0, 0],\n        'UBERON:0002113': [0, 1, 0],\n        'UBERON:0000955': [0, 0, 1],\n    }\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.filter(pl.col(\"UBERON:0000948\") == 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 sample \u2506 series \u2506 UBERON:0000948 \u2506 UBERON:0002113 \u2506 UBERON:0000955 \u2502\n\u2502 ---    \u2506 ---    \u2506 ---            \u2506 ---            \u2506 ---            \u2502\n\u2502 str    \u2506 str    \u2506 i32            \u2506 i32            \u2506 i32            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSM1   \u2506 GSE1   \u2506 1              \u2506 0              \u2506 0              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.head","title":"<code>head(*args, **kwargs)</code>","text":"<p>Wrapper for polars head function.</p>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.save","title":"<code>save(outfile, fmt, metadata=None)</code>","text":"<p>Save the annotations curation.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str | Path</code> <p>Path to outfile.json.</p> required <code>fmt</code> <code>Literal['json', 'parquet', 'csv', 'tsv']</code> <p>File format to save to.</p> required <code>metadata</code> <code>bool</code> <p>If True, will add index titles to each entry.</p> <code>None</code>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.sort_columns","title":"<code>sort_columns()</code>","text":"<p>Sorts term columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.annotations import Annotations\n&gt;&gt;&gt; anno = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, 0, 0],\n        'UBERON:0002113': [0, 1, 0],\n        'UBERON:0000955': [0, 0, 1],\n    }\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.sort_columns()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 series \u2506 sample \u2506 UBERON:0000948 \u2506 UBERON:0000955 \u2506 UBERON:0002113 \u2502\n\u2502 ---    \u2506 ---    \u2506 ---            \u2506 ---            \u2506 ---            \u2502\n\u2502 str    \u2506 str    \u2506 i32            \u2506 i32            \u2506 i32            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSE1   \u2506 GSM1   \u2506 1              \u2506 0              \u2506 0              \u2502\n\u2502 GSE1   \u2506 GSM2   \u2506 0              \u2506 0              \u2506 1              \u2502\n\u2502 GSE2   \u2506 GSM3   \u2506 0              \u2506 1              \u2506 0              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.propagate","title":"<code>propagate(to_terms, ontology, mode, control_col='MONDO:0000000')</code>","text":"<p>Convert annotations to propagated labels.</p> <p>Assigns propagated labels to terms given their annotations.</p> <p>Parameters:</p> Name Type Description Default <code>to_terms</code> <code>list[str]</code> <p>Array of terms to generate labels for, or \"union\"/\"all\".</p> required <code>ontology</code> <code>str</code> <p>The name of an ontology to reference for annotation propagation.</p> required <code>mode</code> <code>Literal[0, 1]</code> <p>Mode of propagation.</p> <pre><code>If mode is 0, this will propagate any positive annotations\nfrom any descendants of the to_terms up to the to_terms.\n\nIf mode 1, this will convert annotations to -1, 0, +1 labels\nwhere for a particular term, if an index is annotated to that term or\nany of its descendants, it recieves a +1 label. If it is annotated to an\nancestor of that term, it receives a 0 (unsure) label. If it is not annotated\nto an ancestor or a descendant of that term, it recieves a -1 label.\nAny indices annotated to the control column are assigned a label of 2 for any\nterms that other indices within the same group are positively labeled to.\n</code></pre> required <code>control_col</code> <code>str</code> <p>Column name for control annotations.</p> <code>'MONDO:0000000'</code> <p>Returns:</p> Type Description <code>Labels | Annotations</code> <p>A Labels curation object with propagated -1, 0, +1 labels (and 2 if controls are</p> <code>Labels | Annotations</code> <p>present). Any entries in <code>index_col</code> that have a 0 annotation/label across all</p> <code>Labels | Annotations</code> <p>entity columns are dropped.</p> <p>Examples:</p> <pre><code>With `mode=0`:\n\n&gt;&gt;&gt; anno = pl.DataFrame(\n        {\n            \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n            \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n            \"UBERON:0000948\": [1, 0, 0],\n            \"UBERON:0002349\": [1, 1, 0],\n            \"UBERON:0002113\": [0, 0, 0],\n            \"UBERON:0000955\": [0, 0, 1],\n        }\n    )\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; anno.propagate(to_terms=[\"UBERON:0000948\"], ontology=\"uberon\", mode=0)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 sample \u2506 series \u2506 UBERON:0000948 \u2502\n\u2502 ---    \u2506 ---    \u2506 ---            \u2502\n\u2502 str    \u2506 str    \u2506 i32            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSM1   \u2506 GSE1   \u2506 1              \u2502\n\u2502 GSM2   \u2506 GSE1   \u2506 1              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nWith `mode=1`:\n\n&gt;&gt;&gt; anno.propagate(to_terms=[\"UBERON:0000948\"], ontology=\"uberon\", mode=1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 sample \u2506 series \u2506 UBERON:0000948 \u2502\n\u2502 ---    \u2506 ---    \u2506 ---            \u2502\n\u2502 str    \u2506 str    \u2506 i32            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSM1   \u2506 GSE1   \u2506 1              \u2502\n\u2502 GSM2   \u2506 GSE1   \u2506 1              \u2502\n\u2502 GSM3   \u2506 GSE2   \u2506 -1             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.select","title":"<code>select(*args, **kwargs)</code>","text":"<p>Select annotation columns while maintaining ids.</p>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Slice both data and ids simultaneously using <code>polars</code> slice.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Index position to begin the slice.</p> required <code>length</code> <code>int | None</code> <p>Number of indices past <code>offset</code> to slice out.</p> <code>None</code> <p>Returns:</p> Type Description <code>Annotations</code> <p>Sliced Annotations object as a subset of the original Annotations.</p>"},{"location":"packages/core/api/curations/annotations/#metahq_core.curations.annotations.Annotations.from_df","title":"<code>from_df(df, index_col, group_cols, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates an Annotations object from a combined DataFrame.</p> <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Polars DataFrame with index and group ID columns and columns for each     attribute entity for each index (e.g. male or female, tissues, diseases, etc).</p> <code>index_col</code> <code>str</code> <p>Name of the column of data that contains the index IDs.</p> <code>group_cols</code> <code>tuple[str, ...]</code> <p>Names of columns of data that contain an ID for each index indicating if it belongs     to a particular group (e.g. dataset, sex, platform, etc.).</p> <p>Returns:</p> Type Description <code>Annotations</code> <p>An Annotations object constructed from <code>df</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.annotations import Annotations\n&gt;&gt;&gt; anno = pl.DataFrame(\n        {\n            \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n            \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n            \"UBERON:0000948\": [1, 0, 0],\n            \"UBERON:0002349\": [1, 1, 0],\n            \"UBERON:0002113\": [0, 0, 0],\n            \"UBERON:0000955\": [0, 0, 1],\n        }\n    )\n&gt;&gt;&gt; anno = Annotations.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 sample \u2506 series \u2506 UBERON:0000948 \u2506 UBERON:0002349 \u2506 UBERON:0002113 \u2506 UBERON:0000955 \u2502\n\u2502 ---    \u2506 ---    \u2506 ---            \u2506 ---            \u2506 ---            \u2506 ---            \u2502\n\u2502 str    \u2506 str    \u2506 i64            \u2506 i64            \u2506 i64            \u2506 i64            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSM1   \u2506 GSE1   \u2506 1              \u2506 1              \u2506 0              \u2506 0              \u2502\n\u2502 GSM2   \u2506 GSE1   \u2506 0              \u2506 1              \u2506 0              \u2506 0              \u2502\n\u2502 GSM3   \u2506 GSE2   \u2506 0              \u2506 0              \u2506 0              \u2506 1              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/curations/ids/","title":"Ids","text":"<p>A class to store and operate on ID columns for tabular data. Specifically made as an index for <code>polars.DataFrame</code> objects which lack index anchoring and tracking.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>DataFrame</code> <p>DataFrame containing ID columns (index, group, platform, etc.)</p> <code>index_col</code> <code>str</code> <p>Name of the column that contains the primary index IDs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.index import Ids\n&gt;&gt;&gt; ids = pl.DataFrame({\n    \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n    \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n    \"platform\": [\"GPL10\", \"GPL10\", \"GPL23\"],\n    })\n&gt;&gt;&gt; ids = ids.from_dataframe(ids, index_col=\"sample\")\n</code></pre>"},{"location":"packages/core/api/curations/ids/#metahq_core.curations.index.Ids.columns","title":"<code>columns</code>  <code>property</code>","text":"<p>Returns columns of self.data. Wrapper for <code>polars.DataFrame.columns</code>.</p>"},{"location":"packages/core/api/curations/ids/#metahq_core.curations.index.Ids.index","title":"<code>index</code>  <code>property</code>","text":"<p>Get the index column as a Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from metahq_core.curations.index import Ids\n&gt;&gt;&gt; ids = pl.DataFrame({\n        \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n        \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n        \"platform\": [\"GPL10\", \"GPL10\", \"GPL23\"],\n    })\n&gt;&gt;&gt; Ids.from_dataframe(ids, index_col=\"sample\")\nshape: (3,)\nSeries: 'sample' [str]\n[\n        \"GSM1\"\n        \"GSM2\"\n        \"GSM3\"\n]\n</code></pre>"},{"location":"packages/core/api/curations/ids/#metahq_core.curations.index.Ids.filter_by_mask","title":"<code>filter_by_mask(mask)</code>","text":"<p>Filter the ids DataFrame using a boolean mask.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>ndarray</code> <p>Array of indices to keep.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.index import Ids\n&gt;&gt;&gt; ids = pl.DataFrame({\n    \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n    \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n    \"platform\": [\"GPL10\", \"GPL10\", \"GPL23\"],\n    })\n&gt;&gt;&gt; ids = Ids.from_dataframe(ids, index_col=\"sample\")\n&gt;&gt;&gt; ids.filter_by_mask(np.array([1, 2])).data\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 sample \u2506 series \u2506 platform \u2502\n\u2502 ---    \u2506 ---    \u2506 ---      \u2502\n\u2502 str    \u2506 str    \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSM2   \u2506 GSE1   \u2506 GPL10    \u2502\n\u2502 GSM3   \u2506 GSE2   \u2506 GPL23    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/curations/ids/#metahq_core.curations.index.Ids.lazy","title":"<code>lazy()</code>","text":"<p>Wrapper for <code>polars.DataFrame.lazy()</code>.</p> <p>Returns:</p> Type Description <code>LazyFrame</code> <p>A <code>polars.LazyFrame</code> object of the <code>data</code> attribute.</p>"},{"location":"packages/core/api/curations/ids/#metahq_core.curations.index.Ids.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Wrapper for <code>polars.DataFrame.to_numpy()</code>.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>The <code>data</code> attribute as a numpy ndarray.</p>"},{"location":"packages/core/api/curations/ids/#metahq_core.curations.index.Ids.from_dataframe","title":"<code>from_dataframe(df, index_col)</code>  <code>classmethod</code>","text":"<p>Creates an Ids object from a polars DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A <code>polars.DataFrame</code> object with at least one column.</p> required <code>index_col</code> <code>str</code> <p>The name of the column in <code>df</code> that should be treated     as the index of the DataFrame.</p> required <p>Returns:</p> Type Description <code>Ids</code> <p>An initialized Ids object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from metahq_core.curations.index import Ids\n&gt;&gt;&gt; ids = pl.DataFrame({\n        \"sample\": [\"GSM1\", \"GSM2\", \"GSM3\"],\n        \"series\": [\"GSE1\", \"GSE1\", \"GSE2\"],\n        \"platform\": [\"GPL10\", \"GPL10\", \"GPL23\"],\n    })\n&gt;&gt;&gt; Ids.from_dataframe(ids, index_col=\"sample\")\n</code></pre>"},{"location":"packages/core/api/curations/ids/#metahq_core.curations.index.Ids.__getitem__","title":"<code>__getitem__(idx)</code>","text":"<p>Slice the Ids frame with various indexing methods.</p>"},{"location":"packages/core/api/curations/ids/#metahq_core.curations.index.Ids.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of rows.</p>"},{"location":"packages/core/api/curations/labels/","title":"Labels","text":"<p>               Bases: <code>BaseCuration</code></p> <p>Class for storing and mutating labels.</p> <p>Currently supports -1, 0, +1 labels.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>DataFrame</code> <p>Polars DataFrame with columns <code>index</code>, <code>groups</code> and columns for each attribute entity for each index (e.g. male or female, tissues, diseases, etc).</p> <code>index_col</code> <code>str</code> <p>Name of the column of data that contains the index IDs.</p> <code>group_cols</code> <code>tuple[str, ...]</code> <p>Names of columns of data that contain an ID for each index indicating if it belongs to a particular group (e.g. dataset, sex, platform, etc.).</p> <code>collapsed</code> <code>bool</code> <p>Indicates if the annotations have already been collapsed.</p>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.entities","title":"<code>entities</code>  <code>property</code>","text":"<p>Returns column names of the Labels frame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col='sample', group_cols=['series'])\n&gt;&gt;&gt; labels.entities\n['UBERON:0000948', 'UBERON:0002113', 'UBERON:0000955']\n</code></pre>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.groups","title":"<code>groups</code>  <code>property</code>","text":"<p>Returns the groups column of the Labels curation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col='sample', group_cols=['series'])\n&gt;&gt;&gt; labels.groups\n['GSE1', 'GSE1', 'GSE2']\n</code></pre>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.ids","title":"<code>ids</code>  <code>property</code>","text":"<p>Return the IDs dataframe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col='sample', group_cols=['series'])\n&gt;&gt;&gt; labels.ids\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 sample \u2506 series \u2502\n\u2502 ---    \u2506 ---    \u2502\n\u2502 str    \u2506 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSM1   \u2506 GSE1   \u2502\n\u2502 GSM2   \u2506 GSE1   \u2502\n\u2502 GSM3   \u2506 GSE2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.index","title":"<code>index</code>  <code>property</code>","text":"<p>Return the index column as a list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col='sample', group_cols=['series'])\n&gt;&gt;&gt; labels.index\n['GSM1', 'GSM2', 'GSM3']\n</code></pre>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.n_indices","title":"<code>n_indices</code>  <code>property</code>","text":"<p>Returns number of indices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col='sample', group_cols=['series'])\n&gt;&gt;&gt; labels.n_indices\n3\n</code></pre>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.n_entities","title":"<code>n_entities</code>  <code>property</code>","text":"<p>Returns number of entities.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n        'UBERON:0002107': [-1, -1, -1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col='sample', group_cols=['series'])\n&gt;&gt;&gt; labels.n_entities\n4\n</code></pre>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.unique_groups","title":"<code>unique_groups</code>  <code>property</code>","text":"<p>Returns unique groups.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col='sample', group_cols=['series'])\n&gt;&gt;&gt; labels.unqiue_groups\n['GSE1', 'GSE2']\n</code></pre>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.add_ids","title":"<code>add_ids(new)</code>","text":"<p>Append new group ID columns to the IDs of a Labels object. The new IDs must have a matching index.</p> <p>Parameters:</p> Name Type Description Default <code>new</code> <code>DataFrame</code> <p>A DataFrame of additional IDs to join with the current index column of <code>data</code>.     Must have a matching index column as the original <code>data</code>.</p> required <p>Returns:</p> Type Description <code>Labels</code> <p>A new Labels object including the new ID columns.</p>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.drop","title":"<code>drop(*args, **kwargs)</code>","text":"<p>Wrapper for polars drop. Drops any of the term columns. ID columns are not dropped through this method.</p>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.filter","title":"<code>filter(condition)</code>","text":"<p>Filter both data and ids simultaneously using a mask.</p> <p>Parameters:</p> Name Type Description Default <code>condition</code> <code>Expr</code> <p>Polars expression for filtering columns.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col=\"sample\", group_cols=[\"series\"])\n&gt;&gt;&gt; labels.filter(pl.col(\"UBERON:0000948\") == 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 sample \u2506 series \u2506 UBERON:0000948 \u2506 UBERON:0002113 \u2506 UBERON:0000955 \u2502\n\u2502 ---    \u2506 ---    \u2506 ---            \u2506 ---            \u2506 ---            \u2502\n\u2502 str    \u2506 str    \u2506 i32            \u2506 i32            \u2506 i32            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSM1   \u2506 GSE1   \u2506 1              \u2506 -1             \u2506 -1             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.head","title":"<code>head(*args, **kwargs)</code>","text":"<p>Wrapper for polars head function.</p>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.save","title":"<code>save(outfile, fmt, metadata=None)</code>","text":"<p>Save the labels curation.</p> <p>Parameters:</p> Name Type Description Default <code>outfile</code> <code>str | Path</code> <p>Path to outfile.json.</p> required <code>fmt</code> <code>Literal['json', 'parquet', 'csv', 'tsv']</code> <p>File format to save to.</p> required <code>metadata</code> <code>str | None</code> <p>Metadata fields to inlcude formatted as a comma delimited string.</p> <code>None</code> <p>Examples:</p> <pre><code>If `metadata` is None, will only save the index column\nwith the remaining labels.\n\n&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col='sample', group_cols=['series'])\n&gt;&gt;&gt; labels.save('/path/to/out.parquet', fmt=\"parquet\")\n</code></pre>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.select","title":"<code>select(*args, **kwargs)</code>","text":"<p>Select label entity columns while maintaining ids.</p>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Slice both data and ids simultaneously using <code>polars</code> slice.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Index position to begin the slice.</p> required <code>length</code> <code>int | None</code> <p>Number of indices past <code>offset</code> to slice out.</p> <code>None</code> <p>Returns:</p> Type Description <code>Labels</code> <p>Sliced Labels object as a subset of the original Labels.</p>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Wrapper for polars <code>to_numpy</code>.</p>"},{"location":"packages/core/api/curations/labels/#metahq_core.curations.labels.Labels.from_df","title":"<code>from_df(df, index_col, group_cols, **kwargs)</code>  <code>classmethod</code>","text":"<p>Creates a Labels object from a combined DataFrame.</p> <p>Attributes:</p> Name Type Description <code>df</code> <code>DataFrame</code> <p>Polars DataFrame with index and group ID columns and columns for each     attribute entity for each index (e.g. male or female, tissues, diseases, etc).</p> <code>index_col</code> <code>str</code> <p>Name of the column of data that contains the index IDs.</p> <code>group_cols</code> <code>tuple[str, ...]</code> <p>Names of columns of data that contain an ID for each index indicating if it belongs     to a particular group (e.g. dataset, sex, platform, etc.).</p> <p>Returns:</p> Type Description <code>Labels</code> <p>A Labels object constructed from <code>df</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.curations.labels import Labels\n&gt;&gt;&gt; labels = {\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'UBERON:0000948': [1, -1, -1],\n        'UBERON:0002113': [-1, 1, -1],\n        'UBERON:0000955': [-1, -1, 1],\n    }\n&gt;&gt;&gt; labels = Labels.from_df(anno, index_col='sample', group_cols=['series'])\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 sample \u2506 series \u2506 UBERON:0000948 \u2506 UBERON:0002113 \u2506 UBERON:0000955 \u2502\n\u2502 ---    \u2506 ---    \u2506 ---            \u2506 ---            \u2506 ---            \u2502\n\u2502 str    \u2506 str    \u2506 i64            \u2506 i64            \u2506 i64            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSM1   \u2506 GSE1   \u2506 1              \u2506 -1             \u2506 -1             \u2502\n\u2502 GSM2   \u2506 GSE1   \u2506 -1             \u2506 -1             \u2506 -1             \u2502\n\u2502 GSM3   \u2506 GSE2   \u2506 -1             \u2506 -1             \u2506 1              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/curations/overview/","title":"Curations","text":"<p>Annotations and Labels have very similar APIs.</p>"},{"location":"packages/core/api/curations/propagator/","title":"Propagator","text":"<p>Class to propagate annotations given an particular ontology structure.</p> <p>Attributes:</p> Name Type Description <code>ontology</code> <code>str</code> <p>The name of an ontology supported by MetaHQ.</p> <code>anno</code> <code>Annotations</code> <p>A MetaHQ Annotations object with columns of ontology terms     rows as samples, and each value is a 1 or 0 indicating if a sample is     annotated to a particular term.</p> <code>to</code> <code>list[str]</code> <p>A list of ontology term IDs to propagate annotations up or down to.</p> <code>family</code> <code>dict[str, DataFrame | list[str]]</code> <p>A pointer to the ancestry and descendants adjacency matrices and ids     denoting their column ids.</p>"},{"location":"packages/core/api/curations/propagator/#metahq_core.curations.propagator.Propagator.propagate_down","title":"<code>propagate_down()</code>","text":"<p>Propagates annotations down to all terms in the annotations curation. If an index is annotated to an ancestor of a term in <code>to</code>, then it is given an annotation of 1 to that term.</p>"},{"location":"packages/core/api/curations/propagator/#metahq_core.curations.propagator.Propagator.propagate_up","title":"<code>propagate_up()</code>","text":"<p>Propagates annotations up to all terms in the annotations curation. If an index is annotated to a descendant of a term in <code>to</code>, then it is given an annotation of 1 to that term.</p>"},{"location":"packages/core/api/query/long_anno/","title":"LongAnnotations","text":"<p>Annotations in long format.</p> <p>Exists to support modularity and readibility within the Query class.</p> <p>Attributes:</p> Name Type Description <code>annotations</code> <code>DataFrame</code> <p>DataFrame with columns storing accession IDs with an <code>id</code> and <code>value</code> column storing multiple annotations for a single entry.</p>"},{"location":"packages/core/api/query/long_anno/#metahq_core.query.LongAnnotations.column_intersection_with","title":"<code>column_intersection_with(columns)</code>","text":"<p>Find intersection between <code>columns</code> and the columns in the <code>annotations</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>list[str]</code> <p>Any list of potential columns in the DataFrame.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>The intersection of columns.</p>"},{"location":"packages/core/api/query/long_anno/#metahq_core.query.LongAnnotations.filter_na","title":"<code>filter_na(column)</code>","text":"<p>Removes entries in a column that are NA-like values (e.g., 'NA' or 'none'). Updates the annotations attribute in place.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>The name of a column in the DataFrame.</p> required"},{"location":"packages/core/api/query/long_anno/#metahq_core.query.LongAnnotations.stage_anchor","title":"<code>stage_anchor(anchor)</code>","text":"<p>Filters NA values from the anchor annotations column.</p> <p>Parameters:</p> Name Type Description Default <code>anchor</code> <code>Literal['id', 'value']</code> <p>The column storing desired format of annotations.</p> required"},{"location":"packages/core/api/query/long_anno/#metahq_core.query.LongAnnotations.stage_level","title":"<code>stage_level(level)</code>","text":"<p>Filters NA values from the specified ID level column. If level is 'group', then it will also remove annotations with index IDs.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Literal['sample', 'series']</code> <p>Annotation level.</p> required"},{"location":"packages/core/api/query/long_anno/#metahq_core.query.LongAnnotations.stage","title":"<code>stage(level, anchor)</code>","text":"<p>Stages the annotations DataFrame to be converted to wide format. Mutates the annotations attribute in place.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Literal['sample', 'series']</code> <p>Annotation level.</p> required <code>anchor</code> <code>Literal['id', 'value']</code> <p>The column storing desired format of annotations.</p> required"},{"location":"packages/core/api/query/long_anno/#metahq_core.query.LongAnnotations.pivot_wide","title":"<code>pivot_wide(level, anchor, id_cols)</code>","text":"<p>Pivots the to wide annotations with one-hot-encoded binary entries for each annotation.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>Literal['sample', 'series']</code> <p>Annotation level.</p> required <code>anchor</code> <code>Literal['id', 'value']</code> <p>The column storing desired format of annotations.</p> required <code>id_cols</code> <code>list[str]</code> <p>Columns to keep as IDs when pivoting.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Annotations in one-hot-encoded wide format with the accession IDs for each annotation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.query import LongAnnotations\n&gt;&gt;&gt; anno = pl.DataFrame({\n        'sample': ['GSM1', 'GSM2', 'GSM3'],\n        'series': ['GSE1', 'GSE1', 'GSE2'],\n        'platform': ['GPL1', 'GPL2', 'GPL2'],\n        'id': ['UBERON:0000948|UBERON:0002349', 'UBERON:0002113', 'UBERON:0000955'],\n        'value': ['heart|myocardium', 'kidney', 'brain'],\n    })\n&gt;&gt;&gt; anno = LongAnnotations(anno)\n&gt;&gt;&gt; anno.pivot_wide(\n        level='sample', anchor='id', id_cols=['sample', 'series']\n    )\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 series \u2506 sample \u2506 UBERON:0000948 \u2506 UBERON:0002349 \u2506 UBERON:0002113 \u2506 UBERON:0000955 \u2502\n\u2502 ---    \u2506 ---    \u2506 ---            \u2506 ---            \u2506 ---            \u2506 ---            \u2502\n\u2502 str    \u2506 str    \u2506 i32            \u2506 i32            \u2506 i32            \u2506 i32            \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 GSE1   \u2506 GSM1   \u2506 1              \u2506 1              \u2506 0              \u2506 0              \u2502\n\u2502 GSE1   \u2506 GSM2   \u2506 0              \u2506 0              \u2506 1              \u2506 0              \u2502\n\u2502 GSE2   \u2506 GSM3   \u2506 0              \u2506 0              \u2506 0              \u2506 1              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"packages/core/api/query/parsed/","title":"ParsedEntry","text":"<p>Dataclass to store parsed entries from the annotations dictionary. Exists to support modularity and readibility within the Query class.</p>"},{"location":"packages/core/api/query/parsed/#metahq_core.query.ParsedEntries.add","title":"<code>add(id_, value, accessions)</code>","text":"<p>Adds an annotation with an ID, value, and accession IDs. Args can be 'NA'.</p>"},{"location":"packages/core/api/query/parsed/#metahq_core.query.ParsedEntries.to_polars","title":"<code>to_polars()</code>","text":"<p>Converts object to a Polars DataFrame.</p>"},{"location":"packages/core/api/query/query/","title":"Query","text":"<p>Class to query the MetaHQ database.</p> <p>Attributes:</p> Name Type Description <code>attribute</code> <code>str</code> <p>Attribute to collect annotations for (e.g., tissue, disease, sex, age)</p> <code>level</code> <code>Literal['sample', 'series']</code> <p>Level of annotations to query.</p> <code>ecodes</code> <code>list[str]</code> <p>Acceptable evidence codes for annotations.</p> <code>species</code> <code>str</code> <p>Species for which to query annotations.</p> <code>technology</code> <code>str</code> <p>Technology of the queried samples.</p> <code>_annotations</code> <code>dict</code> <p>Nested dictionary of annotations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.query import Query\n&gt;&gt;&gt; query = Query(\n        \"tissue\",\n        level=\"sample\",\n        ecodes=[\"expert-curated\"],\n        species=\"homo sapiens\",\n        technology=\"rnaseq\",\n    )\n</code></pre>"},{"location":"packages/core/api/query/query/#metahq_core.query.Query.annotations","title":"<code>annotations(anchor='id')</code>","text":"<p>Retrieve annotations from the MetaHQ database.</p> <p>Parameters:</p> Name Type Description Default <code>anchor</code> <code>Literal['id', 'value']</code> <p>Base of the annotations. Either <code>id</code> or <code>value</code>. Using <code>id</code> will return annotations to ontology terms for tissue and disease attributes, M/F for the sex attribute, or predetermined age groups for the age attribute. Using <code>value</code> will return annotations with the free text names for each id.</p> <code>'id'</code> <p>Returns:</p> Type Description <code>Annotations</code> <p>An <code>Annotations</code> object with one-hot-encoded annotations to the specified attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.query import Query\n&gt;&gt;&gt; query = Query(\n    \"tissue\",\n    level=\"sample\",\n    ecodes=[\"expert-curated\"],\n    species=\"homo sapiens\",\n    technology=\"rnaseq\",\n)\n&gt;&gt;&gt; query.annotations(anchor='id')\n</code></pre>"},{"location":"packages/core/api/query/query/#metahq_core.query.Query.compile_annotations","title":"<code>compile_annotations(id_cols)</code>","text":"<p>Extract attribute annotations and accession IDs from the database.</p> <p>Parameters:</p> Name Type Description Default <code>id_cols</code> <code>list[str]</code> <p>Accession IDs</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Polars DataFrame of all annotations in the annotations dictionary for a single attribute.</p> <p>Raises:</p> Type Description <code>NoResultsFound</code> <p>If no attribute annotations can be found.</p>"},{"location":"packages/core/api/query/query/#metahq_core.query.Query.get_accession_ids","title":"<code>get_accession_ids(entry)</code>","text":"<p>Updates an AccessionIDs object with index, group, and platform IDs from an annotations entry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>str</code> <p>An ID with annotations in the database (i.e., one of the top level keys of     the database.)</p> required <p>Returns:</p> Name Type Description <code>accessions</code> <code>dict[str, str]</code> <p>A populated dictionary of accession IDs and values for the passed entry.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.query import Query\n&gt;&gt;&gt; query = Query(\n    \"tissue\",\n    level=\"sample\",\n    ecodes=[\"expert-curated\"],\n    species=\"homo sapiens\",\n    technology=\"rnaseq\",\n)\n&gt;&gt;&gt; query.get_accession_ids('GSM281311')\n{'sample': 'GSM281311', 'series': 'GSE11151', 'platform': 'GPL570'}\n</code></pre>"},{"location":"packages/core/api/query/query/#metahq_core.query.Query.get_valid_annotations","title":"<code>get_valid_annotations(entry)</code>","text":"<p>Extract id and value annotations for each source of annotations in an entry.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>str</code> <p>str A top-level key of the annotations dictionary.</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>Tuple of the annotation IDs and values.</p>"},{"location":"packages/core/api/query/unparsed/","title":"UnParsedEntry","text":"<p>Stores and extracts items from a single annotation entry of the annotations dictionary.</p> <p>Exists to support modularity and readibility within the Query class.</p> <p>Attributes:</p> Name Type Description <code>entry</code> <code>dict[str, dict[str, dict[str, str] | str]]</code> <p>Annotations for a single entry in the database.</p> <code>attribute</code> <code>str</code> <p>Attribute to extract annotations for.</p> <code>ecodes</code> <code>list[str]</code> <p>Permitted evidence codes for annotations.</p> <code>species</code> <code>str</code> <p>Species for which to extract annotations for.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.query import UnParsedEntry\n&gt;&gt;&gt; entry = {\n        'GSM281311': {\n            'organism': 'homo sapiens',\n            'tissue': {\n                'ursa': {\n                    'id': 'UBERON:0002113', 'value': 'kidney', 'ecode': 'expert-curated'\n                }\n            }\n        }\n    }\n&gt;&gt;&gt; UnParsedEntry(\n        entry,\n        attribute='tissue',\n        ecodes=['expert-curated'],\n        'homo sapiens'\n    )\n</code></pre>"},{"location":"packages/core/api/query/unparsed/#metahq_core.query.UnParsedEntry.get_annotations","title":"<code>get_annotations()</code>","text":"<p>Retrieves the ID and value annotations for a single entry.</p> <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>ID and value annotations for a given attribute. If there are multiple annotations across sources, then they are concatenated with a <code>|</code> delimiter. If no ID or value annotations exist, <code>NA</code> is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.query import UnParsedEntry\n&gt;&gt;&gt; entry = {\n        'GSM281311': {\n            'organism': 'homo sapiens',\n            'tissue': {\n                'ursa': {\n                    'id': 'UBERON:0002113', 'value': 'kidney', 'ecode': 'expert-curated'\n                }\n            }\n        }\n    }\n&gt;&gt;&gt; unparsed = UnParsedEntry(\n        entry,\n        attribute='tissue',\n        ecodes=['expert-curated'],\n        'homo sapiens'\n    )\n&gt;&gt;&gt; unparsed.get_annotations()\n('UBERON:0002113', 'kidney')\n</code></pre>"},{"location":"packages/core/api/query/unparsed/#metahq_core.query.UnParsedEntry.is_acceptable","title":"<code>is_acceptable()</code>","text":"<p>Checks if the entry is not empty and is an acceptable annotation given the passed attribute, ecode, and species.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True or False given the specified attributes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from metahq_core.query import UnParsedEntry\n&gt;&gt;&gt; entry = {\n        'GSM281311': {\n            'organism': 'homo sapiens',\n            'tissue': {\n                'ursa': {\n                    'id': 'UBERON:0002113', 'value': 'kidney', 'ecode': 'expert-curated'\n                }\n            }\n        }\n    }\n&gt;&gt;&gt; unparsed = UnParsedEntry(\n        entry,\n        attribute='tissue',\n        ecodes=['expert-curated'],\n        'homo sapiens'\n    )\n&gt;&gt;&gt; unparsed.is_acceptable()\nTrue\n</code></pre> <p>If an attribute doesn't exist, it will return False.</p> <pre><code>&gt;&gt;&gt; entry = {\n        'GSM315993': {\n            'organism': 'homo sapiens',\n            'sex': {\n                'Johnson 2023': {\n                    'id': 'F', 'ecode': 'expert-curated'\n                }\n            }\n        }\n    }\n&gt;&gt;&gt; unparsed = UnParsedEntry(\n        entry,\n        attribute='tissue',\n        ecodes=['expert-curated'],\n        'homo sapiens'\n    )\n&gt;&gt;&gt; unparsed.is_acceptable()\nFalse\n</code></pre>"},{"location":"packages/core/api/query/unparsed/#metahq_core.query.UnParsedEntry.get_id_value","title":"<code>get_id_value(source_anno)</code>  <code>staticmethod</code>","text":"<p>Extracts the ID and value for an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>source_anno</code> <code>dict[str, str]</code> <p>Annotations from a single source. Has keys ['id', 'value', 'ecode'].</p> required <p>Returns:</p> Type Description <code>tuple[str, str]</code> <p>Tuple of the ID and value for the attribute annotation from a single source.</p>"},{"location":"packages/core/api/util/exceptions/","title":"Exceptions","text":""},{"location":"packages/core/api/util/exceptions/#metahq_core.util.exceptions.NoResultsFound","title":"<code>NoResultsFound</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when no results are found for a given query.</p>"},{"location":"packages/core/api/util/helpers/","title":"Helpers","text":""},{"location":"packages/core/api/util/helpers/#metahq_core.util.helpers.flatten_list","title":"<code>flatten_list(l)</code>","text":"<p>Flattens a list of lists.</p>"},{"location":"packages/core/api/util/helpers/#metahq_core.util.helpers.reverse_dict","title":"<code>reverse_dict(d)</code>","text":"<p>Sets values as keys and keys as values.</p>"},{"location":"packages/core/api/util/helpers/#metahq_core.util.helpers.subset_keys","title":"<code>subset_keys(dict_, subset)</code>","text":"<p>Subset a dictionary by top level keys.</p>"},{"location":"packages/core/api/util/helpers/#metahq_core.util.helpers.merge_list_values","title":"<code>merge_list_values(dict_)</code>","text":"<p>Combine all lists that are values of a dictionary to a single list.</p>"},{"location":"packages/core/api/util/io/","title":"IO","text":"<p>Input/output functions.</p> <p>Author: Parker Hicks Date: 2025-04</p> <p>Last updated: 2025-11-28 by Parker Hicks</p>"},{"location":"packages/core/api/util/io/#metahq_core.util.io.checkdir","title":"<code>checkdir(path, is_file=False)</code>","text":"<p>Check if directory exists. If not, creates it.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>A path to a directory or file.</p> required <code>is_file</code> <code>bool</code> <p>If <code>True</code> will check the parent of the file path.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>A <code>pathlib.Path</code> object of <code>path</code>.</p>"},{"location":"packages/core/api/util/io/#metahq_core.util.io.load_bson","title":"<code>load_bson(file, **kwargs)</code>","text":"<p>Load dictionary from compressed bson.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to file.bson to load.</p> required"},{"location":"packages/core/api/util/io/#metahq_core.util.io.load_json","title":"<code>load_json(file, encoding='utf-8')</code>","text":"<p>Load dictionary from JSON.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to file.json to load.</p> required"},{"location":"packages/core/api/util/io/#metahq_core.util.io.load_txt","title":"<code>load_txt(file, cols=1, delimiter=',', encoding='utf-8')</code>","text":"<p>Loads a txt file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to file.txt to load.</p> required <code>cols</code> <code>int</code> <p>The number of columns in <code>file</code>.</p> <code>1</code> <code>delimiter</code> <code>str | None</code> <p>Character to separate entries if the <code>cols&gt;1</code>.</p> <code>','</code> <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code> <p>Returns:     An list of strings.</p>"},{"location":"packages/core/api/util/io/#metahq_core.util.io.load_txt_sections","title":"<code>load_txt_sections(file, delimiter, encoding='utf-8')</code>","text":"<p>Load a .txt file in sections.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to .txt file to load in sections.</p> required <code>delimiter</code> <code>str</code> <p>Pattern to split entries in the .txt file.</p> required <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Sections of the .txt file separated by the specified delimiter.</p>"},{"location":"packages/core/api/util/io/#metahq_core.util.io.load_yaml","title":"<code>load_yaml(file, encoding='utf-8')</code>","text":"<p>Load a yaml dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>Path to .yaml file to load.</p> required <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code>"},{"location":"packages/core/api/util/io/#metahq_core.util.io.save_bson","title":"<code>save_bson(data, file, **kwargs)</code>","text":"<p>Save dictionary to compressed bson.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary to compress and save.</p> required <code>file</code> <code>str | Path</code> <p>Path to file.txt to save <code>data</code>.</p> required"},{"location":"packages/core/api/util/io/#metahq_core.util.io.save_json","title":"<code>save_json(data, file, encoding='utf-8')</code>","text":"<p>Saves a dictionary to file in JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Dictionary to save.</p> required <code>file</code> <code>str | Path</code> <p>Path to file.txt to save <code>data</code>.</p> required <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code>"},{"location":"packages/core/api/util/io/#metahq_core.util.io.save_txt","title":"<code>save_txt(data, file, delimiter=None, encoding='utf-8')</code>","text":"<p>Save an array or list to a <code>.txt</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>StringArray | list[str]</code> <p>An array or list of string entries.</p> required <code>file</code> <code>str | Path</code> <p>Path to file.txt to save <code>data</code>.</p> required <code>delimiter</code> <code>str | None</code> <p>Allows for multidimensional arrays to be saves as     single dimension arrays by concatenating each     element in each row by the passed delimiter.</p> <code>None</code> <code>encoding</code> <code>str</code> <p>Text encoding format.</p> <code>'utf-8'</code>"},{"location":"packages/core/api/util/progress/","title":"Progress","text":"<p>Rich progress displays.</p> <p>Author: Parker Hicks Date: 2025-09-25</p> <p>Last updated: 2025-09-26 by Parker Hicks</p>"},{"location":"packages/core/api/util/progress/#metahq_core.util.progress.spinner","title":"<code>spinner(desc, p_message, end_message)</code>","text":"<p>Function decorator to apply a rich progress spinner.</p>"},{"location":"packages/core/api/util/progress/#metahq_core.util.progress.progress_bar","title":"<code>progress_bar(padding='')</code>","text":"<p>Creates a custom rich progress bar.</p> <p>Modified from Timothy Gebhard: https://timothygebhard.de/posts/richer-progress-bars-for-rich/</p>"},{"location":"packages/core/api/util/progress/#metahq_core.util.progress.progress_wrapper","title":"<code>progress_wrapper(desc, verbose, total, func, padding='', *args, **kwargs)</code>","text":"<p>Function wrapper to apply a spinner while process ongoing.</p>"},{"location":"packages/core/api/util/progress/#metahq_core.util.progress.get_console","title":"<code>get_console()</code>","text":"<p>Return the Rich Console for console sharing across rich handlers.</p>"},{"location":"packages/core/api/util/supported/","title":"Supported","text":"<p>This script stores file path constants and functions to retrieve those paths.</p> <p>Functions beginning with an underscore are intended to be called through the <code>supported</code> function or are just helpers.</p> <p>Author: Parker Hicks Date: 2025-04-15</p> <p>Last updated: 2025-11-24 by Parker Hicks</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.na_entities","title":"<code>na_entities()</code>","text":"<p>Return annotations not to include</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.disease_ontologies","title":"<code>disease_ontologies()</code>","text":"<p>Return available disease ontologies.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.sexes","title":"<code>sexes()</code>","text":"<p>Return available sexes.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.species_map","title":"<code>species_map()</code>","text":"<p>Return species common and scientific names.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_annotations","title":"<code>get_annotations(level)</code>","text":"<p>Returns the annotations database file for a given level.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_config","title":"<code>get_config()</code>","text":"<p>Loads the MetaHQ config file.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_config_file","title":"<code>get_config_file()</code>","text":"<p>Returns the path to the MetaHQ config file if it exists.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_config_file_no_check","title":"<code>get_config_file_no_check()</code>","text":"<p>Only used to initialize MetaHQ.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_data_dir","title":"<code>get_data_dir()</code>","text":"<p>Extracts the MetaHQ data directory from the config.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_default_data_dir","title":"<code>get_default_data_dir()</code>","text":"<p>Return the default data directory.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_log_dir","title":"<code>get_log_dir()</code>","text":"<p>Return log directory defined in config.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_default_log_dir","title":"<code>get_default_log_dir()</code>","text":"<p>Returns path to default logging directory.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_default_log_file","title":"<code>get_default_log_file()</code>","text":"<p>Returns the path to the default logging file.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.geo_metadata","title":"<code>geo_metadata(level)</code>","text":"<p>Returns the MetaHQ metadata file for the specified level.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_metadata_path","title":"<code>get_metadata_path()</code>","text":"<p>Returns the path to MetaHQ metadata.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_metahq_home","title":"<code>get_metahq_home()</code>","text":"<p>Returns the home directory for MetaHQ.</p> <p>Makes the directory if it doesn't exist.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_ontology_dirs","title":"<code>get_ontology_dirs(onto)</code>","text":"<p>Returns the path to the specified ontology directory.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_ontology_files","title":"<code>get_ontology_files(onto)</code>","text":"<p>Returns the path to the specified ontology obo file.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_ontology_search_db","title":"<code>get_ontology_search_db()</code>","text":"<p>Returns the path to the ontology search database.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_ontology_families","title":"<code>get_ontology_families(onto)</code>","text":"<p>Returns the path to files outlining ontology relationships.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.get_technologies","title":"<code>get_technologies()</code>","text":"<p>Returns the file to technology relationships.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.attributes","title":"<code>attributes(query)</code>","text":"<p>Returns default keys to collect attribute values.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.database_ids","title":"<code>database_ids(query)</code>","text":"<p>Returns supported accession IDs for SRA or GEO.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.ecodes","title":"<code>ecodes(query)</code>","text":"<p>Checks if query is in the supported evidence codes.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.levels","title":"<code>levels(query)</code>","text":"<p>Check if queried level is supported.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.metadata_fields","title":"<code>metadata_fields(level)</code>","text":"<p>Returns supported metadata fields for a specified level.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.ontologies","title":"<code>ontologies(query)</code>","text":"<p>Returns the path to a queried ontology.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.onto_relations","title":"<code>onto_relations(query, relatives)</code>","text":"<p>Returns the path to a queried ontology.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.species","title":"<code>species(query)</code>","text":"<p>Checks if a species is supported by MetaHQ.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.technologies","title":"<code>technologies(query)</code>","text":"<p>Returns supported technologies in MetaHQ.</p>"},{"location":"packages/core/api/util/supported/#metahq_core.util.supported.supported","title":"<code>supported(entity)</code>","text":"<p>Returns supported items for a specified entity.</p>"},{"location":"user-guide/cli/retrieve/","title":"Retrieve Commands","text":"<p>The <code>metahq retrieve</code> commands query the MetaHQ database to retrieve curated annotations and labels for tissues, diseases, sex, and age groups.</p> <p>There is a command for each retrievable attribute:</p> <ul> <li><code>metahq retrieve tissues</code></li> <li><code>metahq retrieve diseases</code></li> <li><code>metahq retrieve sex</code></li> <li><code>metahq retrieve age</code></li> </ul>"},{"location":"user-guide/cli/retrieve/#common-options","title":"Common Options","text":"<p>All retrieve commands share the following common options:</p>"},{"location":"user-guide/cli/retrieve/#required-options","title":"Required Options","text":"<ul> <li><code>--level TEXT</code>: Annotation level to retrieve (<code>sample</code> or <code>series</code>). Default: <code>sample</code></li> <li><code>--filters TEXT</code>: Comma-separated filters in format <code>key=value</code>. Available filters:</li> <li><code>species</code>: Filter by species (e.g., <code>human</code>, <code>mouse</code>)</li> <li><code>ecode</code>: Evidence code (e.g., <code>expert</code>, <code>semi</code>, <code>crowd</code>, <code>any</code>)</li> <li><code>tech</code>: Technology type (e.g., <code>rnaseq</code>, <code>microarray</code>)</li> <li>Combine multiple filters like so: <code>'species=human,ecode=expert,tech=rnaseq'</code></li> </ul>"},{"location":"user-guide/cli/retrieve/#output-options","title":"Output Options","text":"<ul> <li><code>--output PATH</code>: Output file path. Default: <code>annotations</code></li> <li><code>--fmt TEXT</code>: Output format (<code>tsv</code>, <code>csv</code>, or <code>json</code>). Default: <code>parquet</code></li> <li><code>--metadata TEXT</code>: Metadata level to include (<code>sample</code>, <code>series</code>, etc.). Default: <code>default</code> (matches <code>--level</code>)</li> <li>Run <code>metahq supported</code> for all metadata fields.</li> <li>Combine multiple filters like so: <code>'sample,series,description,srp'</code></li> </ul>"},{"location":"user-guide/cli/retrieve/#logging-options","title":"Logging Options","text":"<ul> <li><code>--log-level TEXT</code>: Logging level (<code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>). Default: <code>info</code></li> <li><code>--quiet</code>: Suppress console output (flag)</li> </ul>"},{"location":"user-guide/cli/retrieve/#tissues","title":"Tissues","text":"<p>Retrieve tissue annotations and labels using UBERON ontology terms.</p>"},{"location":"user-guide/cli/retrieve/#additional-options","title":"Additional Options","text":"<ul> <li><code>--terms TEXT</code>: Comma-separated UBERON ontology IDs.</li> <li><code>--mode MODE</code>: Annotation mode (<code>annotate</code> or <code>label</code>). Default: <code>annotate</code></li> <li><code>annotate</code>: Returns inferred annotations using the ontology hierarchy</li> <li><code>label</code>: Returns +1, 0, and -1 labels indicating what a sample is, what it is not, or if it is unknown</li> </ul>"},{"location":"user-guide/cli/retrieve/#usage","title":"Usage","text":"<pre><code>metahq retrieve tissues [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli/retrieve/#examples","title":"Examples","text":"<p>Retrieve human RNA-seq samples with expert annotations with SRA metadata:</p> <pre><code>metahq retrieve tissues --terms \"UBERON:0000948,UBERON:0000955\" \\\n    --level sample --filters \"species=human,ecode=expert,tech=rnaseq\" \\\n    --fmt tsv --output tissues.tsv --metadata \"sample,srx,srp\"\n</code></pre> <p>Retrieve sample labels for all tissue terms with parquet output:</p> <pre><code>metahq retrieve tissues --terms \"all\" \\\n    --level sample --filters \"species=human,ecode=expert,tech=rnaseq\" \\\n    --fmt parquet --output tissues.parquet\n</code></pre> <p>Retrieve series-level annotations with JSON output:</p> <pre><code>metahq retrieve tissues --terms \"UBERON:0000948,UBERON:0000955\" \\\n    --level series --filters \"species=human,ecode=expert,tech=rnaseq\" \\\n    --fmt json --output tissues.json\n</code></pre>"},{"location":"user-guide/cli/retrieve/#diseases","title":"Diseases","text":"<p>Retrieve disease annotations and labels using MONDO ontology terms.</p>"},{"location":"user-guide/cli/retrieve/#additional-options_1","title":"Additional Options","text":"<ul> <li><code>--terms TEXT</code>: Comma-separated MONDO ontology IDs.</li> <li>Use <code>'all'</code> to query all disease terms.</li> <li><code>--mode MODE</code>: Annotation mode (<code>annotate</code> or <code>label</code>). Default: <code>annotate</code></li> <li><code>annotate</code>: Returns inferred annotations using the ontology hierarchy</li> <li><code>label</code>: Returns +1, 0, -1, and 2 labels indicating what a sample is, what it is not, or if it is unknown. Labels of 2 indicate is a sample is a healthy control for that disease.</li> </ul>"},{"location":"user-guide/cli/retrieve/#examples_1","title":"Examples","text":"<p>Retrieve expert-curated human RNA-Seq samples with descriptions:</p> <pre><code>metahq retrieve diseases --terms \"MONDO:0004994\" \\\n    --level sample --filters \"species=human,ecode=expert,tech=rnaseq\" \\\n    --fmt csv --output diseases_filtered.csv --metadata \"sample,description\"\n</code></pre> <p>Retrieve crowd-sourced human microarray samples with descriptions:</p> <pre><code>metahq retrieve diseases --terms \"all\" \\\n    --level sample --filters \"species=human,ecode=crowd,tech=microarray\" \\\n    --fmt parquet --output diseases_filtered.parquet --metadata \"sample,description\"\n</code></pre>"},{"location":"user-guide/cli/retrieve/#sex","title":"Sex","text":"<p>Retrieve sex annotations.</p>"},{"location":"user-guide/cli/retrieve/#additional-options_2","title":"Additional Options","text":"<ul> <li><code>--terms TEXT</code>: Comma-separated sex terms.</li> <li>Available terms: <code>male</code>, <code>female</code></li> </ul>"},{"location":"user-guide/cli/retrieve/#examples_2","title":"Examples","text":"<p>Retrieve all RNA-Seq sex-annotated samples:</p> <pre><code>metahq retrieve sex --terms \"male,female\" \\\n    --level sample --filters \"species=human,ecode=expert,tech=rnaseq\"\n</code></pre> <p>Retrieve all RNA-Seq sex-annotated datasets with SRA metadata:</p> <pre><code>metahq retrieve sex --terms \"male,female\" \\\n    --level series --filters \"species=human,ecode=expert,tech=rnaseq\" \\\n    --metadata \"series,srp,description\"\n</code></pre>"},{"location":"user-guide/cli/retrieve/#age","title":"Age","text":"<p>Retrieve age group annotations.</p>"},{"location":"user-guide/cli/retrieve/#additional-options_3","title":"Additional Options","text":"<ul> <li><code>--terms TEXT</code>: Comma-separated age groups.</li> <li>Check supported age groups with <code>metahq supported</code>.</li> <li>Multiple groups can be combined: <code>fetus,adult</code></li> <li>Use <code>all</code> to retrieve all age groups</li> </ul>"},{"location":"user-guide/cli/retrieve/#examples_3","title":"Examples","text":"<p>Retrieve all RNA-Seq age-annotated samples:</p> <pre><code>metahq retrieve age --terms \"all\" \\\n    --level sample --filters \"species=human,ecode=expert,tech=rnaseq\" \\\n    --fmt csv --output ages.csv\n</code></pre> <p>Retrieve all microarray age-annotated datasets with SRA metadata:</p> <pre><code>metahq retrieve sex --terms \"infant,adolescent,elderly\" \\\n    --level series --filters \"species=human,ecode=expert,tech=microarray\" \\\n    --metadata \"series,srp,description\"\n</code></pre>"},{"location":"user-guide/cli/search/","title":"Search","text":"<p>This command identifies the ontology term IDs most similar to a free-text query. It leverages the BM25 algorithm with the rankbm25 package to perform a lexical search of a query term to the term names and their synonyms in an ontology.</p>"},{"location":"user-guide/cli/search/#options","title":"Options","text":"<ul> <li><code>--query</code>: Any free text input (e.g., \"heart attack\", \"hepatocyte\").</li> <li><code>--type</code>: Supported types are tissue, disease, and celltype.</li> <li><code>--ontology</code>: Supported ontologies are UBERON for tissues and cell types, CL for cell types, and MONDO for diseases.</li> <li><code>--max-results (-k)</code>: Specify the number of top term ID matches to the query that are returned.</li> <li><code>--scores</code>: If passed, will return the score from the BM25 algorithm.</li> <li><code>--extended</code>: If passed, will return the ontology and type in the results.</li> <li><code>--scopes</code>: If passed, will return the scopes of term synonyms in the results.</li> </ul>"},{"location":"user-guide/cli/search/#usage","title":"Usage","text":"<pre><code>metahq search [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli/search/#examples","title":"Examples","text":"<p>Search for the MONDO ID for \"heart attack\":</p> <pre><code>metahq search --query \"heart attack\" --type disease --ontology MONDO -k 5\n</code></pre> <p>Search for \"hepatoctye\" cells and return BM25 scores and view the synonym scopes:</p> <pre><code>metahq search --query \"hepatocyte\" --type celltype --ontology CL --scores --scopes\n</code></pre>"},{"location":"user-guide/cli/setup/","title":"Setup","text":"<p>Every installation of <code>metahq-cli</code> requires an initial setup step. The purpose of this step is to download the MetaHQ database from Zenodo and configure the package.</p> <p>The MetaHQ configuration will always be stored in <code>/path/to/home/MetaHQ</code>.</p>"},{"location":"user-guide/cli/setup/#options","title":"Options","text":"<ul> <li><code>--doi</code>: The Zenodo DOI for a particular MetaHQ database version. Default: <code>latest</code>.</li> <li><code>--data_dir</code>: The Zenodo DOI for a particular MetaHQ database version. Default: <code>/path/to/home/.metahq_data</code>.</li> </ul>"},{"location":"user-guide/cli/setup/#usage","title":"Usage","text":"<pre><code>metahq setup [OPTIONS]\n</code></pre>"},{"location":"user-guide/cli/setup/#examples","title":"Examples","text":"<p>Download the latest MetaHQ database and save to a custom directory.</p> <pre><code>metahq setup --data_dir \"/path/to/custom_dir\"\n</code></pre> <p>Download MetaHQ database v1.0.0</p> <pre><code>metahq setup --doi 17666183\n</code></pre>"}]}